# start of generated code


#+++++ starting CgenClassTable::code +++++


#== generating global data ==
	.data
	.align	2
	.globl	class_nameTab
	.globl	Main_protObj
	.globl	Int_protObj
	.globl	String_protObj
	.globl	bool_const0
	.globl	bool_const1
	.globl	_int_tag
	.globl	_bool_tag
	.globl	_string_tag
_int_tag:
	.word	2
_bool_tag:
	.word	3
_string_tag:
	.word	4
#== generating gc ==
	.globl	_MemMgr_INITIALIZER
_MemMgr_INITIALIZER:
	.word	_NoGC_Init
	.globl	_MemMgr_COLLECTOR
_MemMgr_COLLECTOR:
	.word	_NoGC_Collect
	.globl	_MemMgr_TEST
_MemMgr_TEST:
	.word	0
#== generating constants ==
	.word	-1
str_const125:
	.word	4
	.word	7
	.word	String_dispTab
	.word	int_const18
	.ascii	"HashTable"
	.byte	0	
	.align	2
	.word	-1
str_const124:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const13
	.ascii	"Entry"
	.byte	0	
	.align	2
	.word	-1
str_const123:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const0
	.ascii	"BST"
	.byte	0	
	.align	2
	.word	-1
str_const122:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const15
	.ascii	"BSTNode"
	.byte	0	
	.align	2
	.word	-1
str_const121:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const13
	.ascii	"Queue"
	.byte	0	
	.align	2
	.word	-1
str_const120:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const13
	.ascii	"Stack"
	.byte	0	
	.align	2
	.word	-1
str_const119:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const12
	.ascii	"List"
	.byte	0	
	.align	2
	.word	-1
str_const118:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const12
	.ascii	"Node"
	.byte	0	
	.align	2
	.word	-1
str_const117:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const0
	.ascii	"A2I"
	.byte	0	
	.align	2
	.word	-1
str_const116:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const13
	.ascii	"Mylib"
	.byte	0	
	.align	2
	.word	-1
str_const115:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const11
	.ascii	"Op"
	.byte	0	
	.align	2
	.word	-1
str_const114:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const13
	.ascii	"Throw"
	.byte	0	
	.align	2
	.word	-1
str_const113:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const12
	.ascii	"Main"
	.byte	0	
	.align	2
	.word	-1
str_const112:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const14
	.ascii	"String"
	.byte	0	
	.align	2
	.word	-1
str_const111:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const12
	.ascii	"Bool"
	.byte	0	
	.align	2
	.word	-1
str_const110:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const0
	.ascii	"Int"
	.byte	0	
	.align	2
	.word	-1
str_const109:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const11
	.ascii	"IO"
	.byte	0	
	.align	2
	.word	-1
str_const108:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const14
	.ascii	"Object"
	.byte	0	
	.align	2
	.word	-1
str_const107:
	.word	4
	.word	7
	.word	String_dispTab
	.word	int_const17
	.ascii	"_prim_slot"
	.byte	0	
	.align	2
	.word	-1
str_const106:
	.word	4
	.word	7
	.word	String_dispTab
	.word	int_const18
	.ascii	"SELF_TYPE"
	.byte	0	
	.align	2
	.word	-1
str_const105:
	.word	4
	.word	7
	.word	String_dispTab
	.word	int_const18
	.ascii	"_no_class"
	.byte	0	
	.align	2
	.word	-1
str_const104:
	.word	4
	.word	8
	.word	String_dispTab
	.word	int_const19
	.ascii	"<basic class>"
	.byte	0	
	.align	2
	.word	-1
str_const103:
	.word	4
	.word	7
	.word	String_dispTab
	.word	int_const20
	.ascii	" entries]: "
	.byte	0	
	.align	2
	.word	-1
str_const102:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const11
	.ascii	" ["
	.byte	0	
	.align	2
	.word	-1
str_const101:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const11
	.ascii	")\n"
	.byte	0	
	.align	2
	.word	-1
str_const100:
	.word	4
	.word	7
	.word	String_dispTab
	.word	int_const16
	.ascii	", size: "
	.byte	0	
	.align	2
	.word	-1
str_const99:
	.word	4
	.word	8
	.word	String_dispTab
	.word	int_const21
	.ascii	" (capacity: "
	.byte	0	
	.align	2
	.word	-1
str_const98:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const3
	.ascii	"]"
	.byte	0	
	.align	2
	.word	-1
str_const97:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const11
	.ascii	", "
	.byte	0	
	.align	2
	.word	-1
str_const96:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const3
	.ascii	"["
	.byte	0	
	.align	2
	.word	-1
str_const95:
	.word	4
	.word	9
	.word	String_dispTab
	.word	int_const22
	.ascii	"=== not exist ==="
	.byte	0	
	.align	2
	.word	-1
str_const94:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const15
	.ascii	"Bucket "
	.byte	0	
	.align	2
	.word	-1
str_const93:
	.word	4
	.word	9
	.word	String_dispTab
	.word	int_const22
	.ascii	"HashTable Buckets"
	.byte	0	
	.align	2
	.word	-1
str_const92:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const11
	.ascii	"\")"
	.byte	0	
	.align	2
	.word	-1
str_const91:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const0
	.ascii	", \""
	.byte	0	
	.align	2
	.word	-1
str_const90:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const3
	.ascii	"("
	.byte	0	
	.align	2
	.word	-1
str_const89:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const3
	.ascii	" "
	.byte	0	
	.align	2
	.word	-1
str_const88:
	.word	4
	.word	7
	.word	String_dispTab
	.word	int_const17
	.ascii	"Empty BST\n"
	.byte	0	
	.align	2
	.word	-1
str_const87:
	.word	4
	.word	12
	.word	String_dispTab
	.word	int_const23
	.ascii	"Queue is empty, front failed."
	.byte	0	
	.align	2
	.word	-1
str_const86:
	.word	4
	.word	12
	.word	String_dispTab
	.word	int_const24
	.ascii	"Queue is empty, dequeue failed."
	.byte	0	
	.align	2
	.word	-1
str_const85:
	.word	4
	.word	12
	.word	String_dispTab
	.word	int_const25
	.ascii	"Stack is empty, peek failed."
	.byte	0	
	.align	2
	.word	-1
str_const84:
	.word	4
	.word	11
	.word	String_dispTab
	.word	int_const26
	.ascii	"Stack is empty, pop failed."
	.byte	0	
	.align	2
	.word	-1
str_const83:
	.word	4
	.word	9
	.word	String_dispTab
	.word	int_const27
	.ascii	"data-structures.cl"
	.byte	0	
	.align	2
	.word	-1
str_const82:
	.word	4
	.word	8
	.word	String_dispTab
	.word	int_const19
	.ascii	"End of list.\n"
	.byte	0	
	.align	2
	.word	-1
str_const81:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const12
	.ascii	" => "
	.byte	0	
	.align	2
	.word	-1
str_const80:
	.word	4
	.word	13
	.word	String_dispTab
	.word	int_const28
	.ascii	"Wrong index, nodex access failed."
	.byte	0	
	.align	2
	.word	-1
str_const79:
	.word	4
	.word	13
	.word	String_dispTab
	.word	int_const29
	.ascii	"Wrong index, valx access failed."
	.byte	0	
	.align	2
	.word	-1
str_const78:
	.word	4
	.word	11
	.word	String_dispTab
	.word	int_const30
	.ascii	" not found, search failed."
	.byte	0	
	.align	2
	.word	-1
str_const77:
	.word	4
	.word	11
	.word	String_dispTab
	.word	int_const30
	.ascii	" not found, delete failed."
	.byte	0	
	.align	2
	.word	-1
str_const76:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const13
	.ascii	"Item "
	.byte	0	
	.align	2
	.word	-1
str_const75:
	.word	4
	.word	11
	.word	String_dispTab
	.word	int_const26
	.ascii	"Wrong index, delete failed."
	.byte	0	
	.align	2
	.word	-1
str_const74:
	.word	4
	.word	11
	.word	String_dispTab
	.word	int_const26
	.ascii	"Wrong index, insert failed."
	.byte	0	
	.align	2
	.word	-1
str_const73:
	.word	4
	.word	7
	.word	String_dispTab
	.word	int_const18
	.ascii	"Head Node"
	.byte	0	
	.align	2
	.word	-1
str_const72:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const13
	.ascii	"/ -> "
	.byte	0	
	.align	2
	.word	-1
str_const71:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const12
	.ascii	" -> "
	.byte	0	
	.align	2
	.word	-1
str_const70:
	.word	4
	.word	15
	.word	String_dispTab
	.word	int_const31
	.ascii	"Behind node is NULL, deleteBehind failed."
	.byte	0	
	.align	2
	.word	-1
str_const69:
	.word	4
	.word	12
	.word	String_dispTab
	.word	int_const25
	.ascii	"Node is NULL in linkBehindN."
	.byte	0	
	.align	2
	.word	-1
str_const68:
	.word	4
	.word	12
	.word	String_dispTab
	.word	int_const25
	.ascii	"Node is NULL in linkBeforeN."
	.byte	0	
	.align	2
	.word	-1
str_const67:
	.word	4
	.word	12
	.word	String_dispTab
	.word	int_const25
	.ascii	"value is NULL in linkBehind."
	.byte	0	
	.align	2
	.word	-1
str_const66:
	.word	4
	.word	12
	.word	String_dispTab
	.word	int_const25
	.ascii	"value is NULL in linkBefore."
	.byte	0	
	.align	2
	.word	-1
str_const65:
	.word	4
	.word	11
	.word	String_dispTab
	.word	int_const7
	.ascii	"value is NULL in assign."
	.byte	0	
	.align	2
	.word	-1
str_const64:
	.word	4
	.word	13
	.word	String_dispTab
	.word	int_const29
	.ascii	"initial value is NULL, init Err."
	.byte	0	
	.align	2
	.word	-1
str_const63:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const15
	.ascii	"list.cl"
	.byte	0	
	.align	2
	.word	-1
str_const62:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const3
	.ascii	"+"
	.byte	0	
	.align	2
	.word	-1
str_const61:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const3
	.ascii	"-"
	.byte	0	
	.align	2
	.word	-1
str_const60:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const3
	.ascii	"9"
	.byte	0	
	.align	2
	.word	-1
str_const59:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const3
	.ascii	"8"
	.byte	0	
	.align	2
	.word	-1
str_const58:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const3
	.ascii	"7"
	.byte	0	
	.align	2
	.word	-1
str_const57:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const3
	.ascii	"6"
	.byte	0	
	.align	2
	.word	-1
str_const56:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const3
	.ascii	"5"
	.byte	0	
	.align	2
	.word	-1
str_const55:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const3
	.ascii	"4"
	.byte	0	
	.align	2
	.word	-1
str_const54:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const3
	.ascii	"3"
	.byte	0	
	.align	2
	.word	-1
str_const53:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const3
	.ascii	"2"
	.byte	0	
	.align	2
	.word	-1
str_const52:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const3
	.ascii	"1"
	.byte	0	
	.align	2
	.word	-1
str_const51:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const3
	.ascii	"0"
	.byte	0	
	.align	2
	.word	-1
str_const50:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const0
	.ascii	"=> "
	.byte	0	
	.align	2
	.word	-1
str_const49:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const3
	.ascii	"\n"
	.byte	0	
	.align	2
	.word	-1
str_const48:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const3
	.ascii	"\t"
	.byte	0	
	.align	2
	.word	-1
str_const47:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const11
	.ascii	"  "
	.byte	0	
	.align	2
	.word	-1
str_const46:
	.word	4
	.word	10
	.word	String_dispTab
	.word	int_const32
	.ascii	"item2i received void."
	.byte	0	
	.align	2
	.word	-1
str_const45:
	.word	4
	.word	7
	.word	String_dispTab
	.word	int_const17
	.ascii	"other type"
	.byte	0	
	.align	2
	.word	-1
str_const44:
	.word	4
	.word	10
	.word	String_dispTab
	.word	int_const32
	.ascii	"item2a received void."
	.byte	0	
	.align	2
	.word	-1
str_const43:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const13
	.ascii	"false"
	.byte	0	
	.align	2
	.word	-1
str_const42:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const12
	.ascii	"true"
	.byte	0	
	.align	2
	.word	-1
str_const41:
	.word	4
	.word	13
	.word	String_dispTab
	.word	int_const33
	.ascii	"Division by zero or minus in Op.mod"
	.byte	0	
	.align	2
	.word	-1
str_const40:
	.word	4
	.word	10
	.word	String_dispTab
	.word	int_const34
	.ascii	"\n==== warning info: "
	.byte	0	
	.align	2
	.word	-1
str_const39:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const14
	.ascii	" ====\n"
	.byte	0	
	.align	2
	.word	-1
str_const38:
	.word	4
	.word	9
	.word	String_dispTab
	.word	int_const27
	.ascii	"\n==== error info: "
	.byte	0	
	.align	2
	.word	-1
str_const37:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const15
	.ascii	"base.cl"
	.byte	0	
	.align	2
	.word	-1
str_const36:
	.word	4
	.word	7
	.word	String_dispTab
	.word	int_const20
	.ascii	"ht1.get(10)"
	.byte	0	
	.align	2
	.word	-1
str_const35:
	.word	4
	.word	7
	.word	String_dispTab
	.word	int_const17
	.ascii	"ht1.get(2)"
	.byte	0	
	.align	2
	.word	-1
str_const34:
	.word	4
	.word	7
	.word	String_dispTab
	.word	int_const17
	.ascii	"ht1.get(3)"
	.byte	0	
	.align	2
	.word	-1
str_const33:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const14
	.ascii	"V2-new"
	.byte	0	
	.align	2
	.word	-1
str_const32:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const11
	.ascii	"V8"
	.byte	0	
	.align	2
	.word	-1
str_const31:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const11
	.ascii	"V7"
	.byte	0	
	.align	2
	.word	-1
str_const30:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const11
	.ascii	"V6"
	.byte	0	
	.align	2
	.word	-1
str_const29:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const11
	.ascii	"V5"
	.byte	0	
	.align	2
	.word	-1
str_const28:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const11
	.ascii	"V4"
	.byte	0	
	.align	2
	.word	-1
str_const27:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const11
	.ascii	"V3"
	.byte	0	
	.align	2
	.word	-1
str_const26:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const11
	.ascii	"V2"
	.byte	0	
	.align	2
	.word	-1
str_const25:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const11
	.ascii	"V1"
	.byte	0	
	.align	2
	.word	-1
str_const24:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const11
	.ascii	"V0"
	.byte	0	
	.align	2
	.word	-1
str_const23:
	.word	4
	.word	9
	.word	String_dispTab
	.word	int_const35
	.ascii	"bst1.search(333)"
	.byte	0	
	.align	2
	.word	-1
str_const22:
	.word	4
	.word	8
	.word	String_dispTab
	.word	int_const36
	.ascii	"bst1.search(24)"
	.byte	0	
	.align	2
	.word	-1
str_const21:
	.word	4
	.word	8
	.word	String_dispTab
	.word	int_const37
	.ascii	"bst1.search(1)"
	.byte	0	
	.align	2
	.word	-1
str_const20:
	.word	4
	.word	9
	.word	String_dispTab
	.word	int_const35
	.ascii	"queue1.isEmpty()"
	.byte	0	
	.align	2
	.word	-1
str_const19:
	.word	4
	.word	9
	.word	String_dispTab
	.word	int_const35
	.ascii	"stack1.isEmpty()"
	.byte	0	
	.align	2
	.word	-1
str_const18:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const4
	.byte	0	
	.align	2
	.word	-1
str_const17:
	.word	4
	.word	8
	.word	String_dispTab
	.word	int_const37
	.ascii	"list1.length()"
	.byte	0	
	.align	2
	.word	-1
str_const16:
	.word	4
	.word	8
	.word	String_dispTab
	.word	int_const36
	.ascii	"list1.isEmpty()"
	.byte	0	
	.align	2
	.word	-1
str_const15:
	.word	4
	.word	11
	.word	String_dispTab
	.word	int_const30
	.ascii	"list1.valx(list1.length())"
	.byte	0	
	.align	2
	.word	-1
str_const14:
	.word	4
	.word	8
	.word	String_dispTab
	.word	int_const19
	.ascii	"list1.valx(1)"
	.byte	0	
	.align	2
	.word	-1
str_const13:
	.word	4
	.word	8
	.word	String_dispTab
	.word	int_const19
	.ascii	"list1.valx(0)"
	.byte	0	
	.align	2
	.word	-1
str_const12:
	.word	4
	.word	9
	.word	String_dispTab
	.word	int_const27
	.ascii	"list1.search(true)"
	.byte	0	
	.align	2
	.word	-1
str_const11:
	.word	4
	.word	8
	.word	String_dispTab
	.word	int_const36
	.ascii	"list1.search(1)"
	.byte	0	
	.align	2
	.word	-1
str_const10:
	.word	4
	.word	8
	.word	String_dispTab
	.word	int_const36
	.ascii	"any base object"
	.byte	0	
	.align	2
	.word	-1
str_const9:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const13
	.ascii	"hello"
	.byte	0	
	.align	2
	.word	-1
str_const8:
	.word	4
	.word	18
	.word	String_dispTab
	.word	int_const38
	.ascii	"\n====================================================\n"
	.byte	0	
	.align	2
	.word	-1
str_const7:
	.word	4
	.word	5
	.word	String_dispTab
	.word	int_const0
	.ascii	"ht1"
	.byte	0	
	.align	2
	.word	-1
str_const6:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const12
	.ascii	"bst1"
	.byte	0	
	.align	2
	.word	-1
str_const5:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const14
	.ascii	"queue1"
	.byte	0	
	.align	2
	.word	-1
str_const4:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const14
	.ascii	"stack1"
	.byte	0	
	.align	2
	.word	-1
str_const3:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const13
	.ascii	"list3"
	.byte	0	
	.align	2
	.word	-1
str_const2:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const13
	.ascii	"list2"
	.byte	0	
	.align	2
	.word	-1
str_const1:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const13
	.ascii	"list1"
	.byte	0	
	.align	2
	.word	-1
str_const0:
	.word	4
	.word	6
	.word	String_dispTab
	.word	int_const15
	.ascii	"main.cl"
	.byte	0	
	.align	2
	.word	-1
int_const38:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	54
	.word	-1
int_const37:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	14
	.word	-1
int_const36:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	15
	.word	-1
int_const35:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	16
	.word	-1
int_const34:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	20
	.word	-1
int_const33:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	35
	.word	-1
int_const32:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	21
	.word	-1
int_const31:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	41
	.word	-1
int_const30:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	26
	.word	-1
int_const29:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	32
	.word	-1
int_const28:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	33
	.word	-1
int_const27:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	18
	.word	-1
int_const26:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	27
	.word	-1
int_const25:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	28
	.word	-1
int_const24:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	31
	.word	-1
int_const23:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	29
	.word	-1
int_const22:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	17
	.word	-1
int_const21:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	12
	.word	-1
int_const20:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	11
	.word	-1
int_const19:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	13
	.word	-1
int_const18:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	9
	.word	-1
int_const17:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	10
	.word	-1
int_const16:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	8
	.word	-1
int_const15:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	7
	.word	-1
int_const14:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	6
	.word	-1
int_const13:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	5
	.word	-1
int_const12:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	4
	.word	-1
int_const11:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	2
	.word	-1
int_const10:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	77
	.word	-1
int_const9:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	333
	.word	-1
int_const8:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	102
	.word	-1
int_const7:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	24
	.word	-1
int_const6:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	90
	.word	-1
int_const5:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	1234567890
	.word	-1
int_const4:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	0
	.word	-1
int_const3:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	1
	.word	-1
int_const2:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	456
	.word	-1
int_const1:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	123
	.word	-1
int_const0:
	.word	2
	.word	4
	.word	Int_dispTab
	.word	3
	.word	-1
bool_const0:
	.word	3
	.word	4
	.word	Bool_dispTab
	.word	0
	.word	-1
bool_const1:
	.word	3
	.word	4
	.word	Bool_dispTab
	.word	1
#== generating name table ==
class_nameTab:
	.word	str_const108
#== child: IO ==
#== child: Int ==
#== child: Bool ==
#== child: String ==
#== child: Op ==
#== child: A2I ==
#== child: Node ==
#== child: BST ==
#== child: Entry ==
#== child: HashTable ==

	.word	str_const109
#== child: Main ==
#== child: Throw ==
#== child: Mylib ==

	.word	str_const110

	.word	str_const111

	.word	str_const112

	.word	str_const113

	.word	str_const114

	.word	str_const115

	.word	str_const116

	.word	str_const117

	.word	str_const118
#== child: List ==
#== child: BSTNode ==

	.word	str_const119
#== child: Stack ==
#== child: Queue ==

	.word	str_const120

	.word	str_const121

	.word	str_const122

	.word	str_const123

	.word	str_const124

	.word	str_const125

#== generating object table ==
class_objTab:
	.word	Object_protObj
	.word	Object_init
	.word	IO_protObj
	.word	IO_init
	.word	Int_protObj
	.word	Int_init
	.word	Bool_protObj
	.word	Bool_init
	.word	String_protObj
	.word	String_init
	.word	Main_protObj
	.word	Main_init
	.word	Throw_protObj
	.word	Throw_init
	.word	Op_protObj
	.word	Op_init
	.word	Mylib_protObj
	.word	Mylib_init
	.word	A2I_protObj
	.word	A2I_init
	.word	Node_protObj
	.word	Node_init
	.word	List_protObj
	.word	List_init
	.word	Stack_protObj
	.word	Stack_init
	.word	Queue_protObj
	.word	Queue_init
	.word	BSTNode_protObj
	.word	BSTNode_init
	.word	BST_protObj
	.word	BST_init
	.word	Entry_protObj
	.word	Entry_init
	.word	HashTable_protObj
	.word	HashTable_init
#== generating dispatch table ==
Object_dispTab:
#== method # 0 ==
	.word	Object.abort
#== method # 1 ==
	.word	Object.type_name
#== method # 2 ==
	.word	Object.copy
IO_dispTab:
#== method # 0 ==
	.word	Object.abort
#== method # 1 ==
	.word	Object.type_name
#== method # 2 ==
	.word	Object.copy
#== method # 3 ==
	.word	IO.out_string
#== method # 4 ==
	.word	IO.out_int
#== method # 5 ==
	.word	IO.in_string
#== method # 6 ==
	.word	IO.in_int
Int_dispTab:
#== method # 0 ==
	.word	Object.abort
#== method # 1 ==
	.word	Object.type_name
#== method # 2 ==
	.word	Object.copy
Bool_dispTab:
#== method # 0 ==
	.word	Object.abort
#== method # 1 ==
	.word	Object.type_name
#== method # 2 ==
	.word	Object.copy
String_dispTab:
#== method # 0 ==
	.word	Object.abort
#== method # 1 ==
	.word	Object.type_name
#== method # 2 ==
	.word	Object.copy
#== method # 3 ==
	.word	String.length
#== method # 4 ==
	.word	String.concat
#== method # 5 ==
	.word	String.substr
Main_dispTab:
#== method # 0 ==
	.word	Object.abort
#== method # 1 ==
	.word	Object.type_name
#== method # 2 ==
	.word	Object.copy
#== method # 3 ==
	.word	IO.out_string
#== method # 4 ==
	.word	IO.out_int
#== method # 5 ==
	.word	IO.in_string
#== method # 6 ==
	.word	IO.in_int
#== method # 7 ==
	.word	Main.main
Throw_dispTab:
#== method # 0 ==
	.word	Object.abort
#== method # 1 ==
	.word	Object.type_name
#== method # 2 ==
	.word	Object.copy
#== method # 3 ==
	.word	IO.out_string
#== method # 4 ==
	.word	IO.out_int
#== method # 5 ==
	.word	IO.in_string
#== method # 6 ==
	.word	IO.in_int
#== method # 7 ==
	.word	Throw.error
#== method # 8 ==
	.word	Throw.warning
Op_dispTab:
#== method # 0 ==
	.word	Object.abort
#== method # 1 ==
	.word	Object.type_name
#== method # 2 ==
	.word	Object.copy
#== method # 3 ==
	.word	Op.and
#== method # 4 ==
	.word	Op.or
#== method # 5 ==
	.word	Op.xor
#== method # 6 ==
	.word	Op.mod
Mylib_dispTab:
#== method # 0 ==
	.word	Object.abort
#== method # 1 ==
	.word	Object.type_name
#== method # 2 ==
	.word	Object.copy
#== method # 3 ==
	.word	IO.out_string
#== method # 4 ==
	.word	IO.out_int
#== method # 5 ==
	.word	IO.in_string
#== method # 6 ==
	.word	IO.in_int
#== method # 7 ==
	.word	Mylib.i2b
#== method # 8 ==
	.word	Mylib.b2a
#== method # 9 ==
	.word	Mylib.item2a
#== method # 10 ==
	.word	Mylib.item2i
#== method # 11 ==
	.word	Mylib.item2s
#== method # 12 ==
	.word	Mylib.item2b
#== method # 13 ==
	.word	Mylib.printspc
#== method # 14 ==
	.word	Mylib.printtab
#== method # 15 ==
	.word	Mylib.println
#== method # 16 ==
	.word	Mylib.debug
A2I_dispTab:
#== method # 0 ==
	.word	Object.abort
#== method # 1 ==
	.word	Object.type_name
#== method # 2 ==
	.word	Object.copy
#== method # 3 ==
	.word	A2I.c2i
#== method # 4 ==
	.word	A2I.i2c
#== method # 5 ==
	.word	A2I.a2i
#== method # 6 ==
	.word	A2I.a2i_aux
#== method # 7 ==
	.word	A2I.i2a
#== method # 8 ==
	.word	A2I.i2a_aux
Node_dispTab:
#== method # 0 ==
	.word	Object.abort
#== method # 1 ==
	.word	Object.type_name
#== method # 2 ==
	.word	Object.copy
#== method # 3 ==
	.word	Node.node_init
#== method # 4 ==
	.word	Node.link
#== method # 5 ==
	.word	Node.assign
#== method # 6 ==
	.word	Node.next
#== method # 7 ==
	.word	Node.val
#== method # 8 ==
	.word	Node.linkBefore
#== method # 9 ==
	.word	Node.linkBehind
#== method # 10 ==
	.word	Node.linkBeforeN
#== method # 11 ==
	.word	Node.linkBehindN
#== method # 12 ==
	.word	Node.deleteBehind
#== method # 13 ==
	.word	Node.print
List_dispTab:
#== method # 0 ==
	.word	Object.abort
#== method # 1 ==
	.word	Object.type_name
#== method # 2 ==
	.word	Object.copy
#== method # 3 ==
	.word	Node.node_init
#== method # 4 ==
	.word	Node.link
#== method # 5 ==
	.word	Node.assign
#== method # 6 ==
	.word	Node.next
#== method # 7 ==
	.word	Node.val
#== method # 8 ==
	.word	Node.linkBefore
#== method # 9 ==
	.word	Node.linkBehind
#== method # 10 ==
	.word	Node.linkBeforeN
#== method # 11 ==
	.word	Node.linkBehindN
#== method # 12 ==
	.word	Node.deleteBehind
#== method # 13 ==
	.word	List.print
#== method # 14 ==
	.word	List.list_init
#== method # 15 ==
	.word	List.insertIdx
#== method # 16 ==
	.word	List.insertIdxN
#== method # 17 ==
	.word	List.deleteIdx
#== method # 18 ==
	.word	List.insert
#== method # 19 ==
	.word	List.delete
#== method # 20 ==
	.word	List.search
#== method # 21 ==
	.word	List.isEmpty
#== method # 22 ==
	.word	List.length
#== method # 23 ==
	.word	List.valx
#== method # 24 ==
	.word	List.nodex
Stack_dispTab:
#== method # 0 ==
	.word	Object.abort
#== method # 1 ==
	.word	Object.type_name
#== method # 2 ==
	.word	Object.copy
#== method # 3 ==
	.word	Node.node_init
#== method # 4 ==
	.word	Node.link
#== method # 5 ==
	.word	Node.assign
#== method # 6 ==
	.word	Node.next
#== method # 7 ==
	.word	Node.val
#== method # 8 ==
	.word	Node.linkBefore
#== method # 9 ==
	.word	Node.linkBehind
#== method # 10 ==
	.word	Node.linkBeforeN
#== method # 11 ==
	.word	Node.linkBehindN
#== method # 12 ==
	.word	Node.deleteBehind
#== method # 13 ==
	.word	List.print
#== method # 14 ==
	.word	List.list_init
#== method # 15 ==
	.word	List.insertIdx
#== method # 16 ==
	.word	List.insertIdxN
#== method # 17 ==
	.word	List.deleteIdx
#== method # 18 ==
	.word	List.insert
#== method # 19 ==
	.word	List.delete
#== method # 20 ==
	.word	List.search
#== method # 21 ==
	.word	List.isEmpty
#== method # 22 ==
	.word	List.length
#== method # 23 ==
	.word	List.valx
#== method # 24 ==
	.word	List.nodex
#== method # 25 ==
	.word	Stack.stack_init
#== method # 26 ==
	.word	Stack.push
#== method # 27 ==
	.word	Stack.pop
#== method # 28 ==
	.word	Stack.peek
Queue_dispTab:
#== method # 0 ==
	.word	Object.abort
#== method # 1 ==
	.word	Object.type_name
#== method # 2 ==
	.word	Object.copy
#== method # 3 ==
	.word	Node.node_init
#== method # 4 ==
	.word	Node.link
#== method # 5 ==
	.word	Node.assign
#== method # 6 ==
	.word	Node.next
#== method # 7 ==
	.word	Node.val
#== method # 8 ==
	.word	Node.linkBefore
#== method # 9 ==
	.word	Node.linkBehind
#== method # 10 ==
	.word	Node.linkBeforeN
#== method # 11 ==
	.word	Node.linkBehindN
#== method # 12 ==
	.word	Node.deleteBehind
#== method # 13 ==
	.word	List.print
#== method # 14 ==
	.word	List.list_init
#== method # 15 ==
	.word	List.insertIdx
#== method # 16 ==
	.word	List.insertIdxN
#== method # 17 ==
	.word	List.deleteIdx
#== method # 18 ==
	.word	List.insert
#== method # 19 ==
	.word	List.delete
#== method # 20 ==
	.word	List.search
#== method # 21 ==
	.word	List.isEmpty
#== method # 22 ==
	.word	List.length
#== method # 23 ==
	.word	List.valx
#== method # 24 ==
	.word	List.nodex
#== method # 25 ==
	.word	Queue.queue_init
#== method # 26 ==
	.word	Queue.enqueue
#== method # 27 ==
	.word	Queue.dequeue
#== method # 28 ==
	.word	Queue.front
BSTNode_dispTab:
#== method # 0 ==
	.word	Object.abort
#== method # 1 ==
	.word	Object.type_name
#== method # 2 ==
	.word	Object.copy
#== method # 3 ==
	.word	Node.node_init
#== method # 4 ==
	.word	Node.link
#== method # 5 ==
	.word	Node.assign
#== method # 6 ==
	.word	Node.next
#== method # 7 ==
	.word	Node.val
#== method # 8 ==
	.word	Node.linkBefore
#== method # 9 ==
	.word	Node.linkBehind
#== method # 10 ==
	.word	Node.linkBeforeN
#== method # 11 ==
	.word	Node.linkBehindN
#== method # 12 ==
	.word	Node.deleteBehind
#== method # 13 ==
	.word	Node.print
#== method # 14 ==
	.word	BSTNode.bstnode_init
#== method # 15 ==
	.word	BSTNode.left
#== method # 16 ==
	.word	BSTNode.right
#== method # 17 ==
	.word	BSTNode.setLeft
#== method # 18 ==
	.word	BSTNode.setRight
#== method # 19 ==
	.word	BSTNode.value
BST_dispTab:
#== method # 0 ==
	.word	Object.abort
#== method # 1 ==
	.word	Object.type_name
#== method # 2 ==
	.word	Object.copy
#== method # 3 ==
	.word	BST.bst_init
#== method # 4 ==
	.word	BST.insert
#== method # 5 ==
	.word	BST.insertHelper
#== method # 6 ==
	.word	BST.search
#== method # 7 ==
	.word	BST.searchHelper
#== method # 8 ==
	.word	BST.delete
#== method # 9 ==
	.word	BST.deleteHelper
#== method # 10 ==
	.word	BST.findMinVal
#== method # 11 ==
	.word	BST.deleteMin
#== method # 12 ==
	.word	BST.printInOrder
#== method # 13 ==
	.word	BST.inOrder
#== method # 14 ==
	.word	BST.size
#== method # 15 ==
	.word	BST.isEmpty
Entry_dispTab:
#== method # 0 ==
	.word	Object.abort
#== method # 1 ==
	.word	Object.type_name
#== method # 2 ==
	.word	Object.copy
#== method # 3 ==
	.word	Entry.init
#== method # 4 ==
	.word	Entry.getKey
#== method # 5 ==
	.word	Entry.getValue
#== method # 6 ==
	.word	Entry.setValue
#== method # 7 ==
	.word	Entry.equalsKey
#== method # 8 ==
	.word	Entry.print
HashTable_dispTab:
#== method # 0 ==
	.word	Object.abort
#== method # 1 ==
	.word	Object.type_name
#== method # 2 ==
	.word	Object.copy
#== method # 3 ==
	.word	HashTable.ht_init
#== method # 4 ==
	.word	HashTable.hashFunc
#== method # 5 ==
	.word	HashTable.getBucket
#== method # 6 ==
	.word	HashTable.put
#== method # 7 ==
	.word	HashTable.get
#== method # 8 ==
	.word	HashTable.remove
#== method # 9 ==
	.word	HashTable.printBucket
#== method # 10 ==
	.word	HashTable.print
#== method # 11 ==
	.word	HashTable.getSize
#== method # 12 ==
	.word	HashTable.getCapacity
#== method # 13 ==
	.word	HashTable.isEmpty
#== generating prototype objects ==
	.word	-1
Object_protObj:
	.word	0	# class tag
	.word	3	# size
	.word	Object_dispTab
	.word	-1
IO_protObj:
	.word	1	# class tag
	.word	3	# size
	.word	IO_dispTab
	.word	-1
Int_protObj:
	.word	2	# class tag
	.word	4	# size
	.word	Int_dispTab
	.word	0	# val(0)
	.word	-1
Bool_protObj:
	.word	3	# class tag
	.word	4	# size
	.word	Bool_dispTab
	.word	0	# val(0)
	.word	-1
String_protObj:
	.word	4	# class tag
	.word	5	# size
	.word	String_dispTab
	.word	int_const4	# int(0)
	.word	0	# str(0)
	.word	-1
Main_protObj:
	.word	5	# class tag
	.word	11	# size
	.word	Main_dispTab
	.word	0	# void
	.word	0	# void
	.word	0	# void
	.word	0	# void
	.word	0	# void
	.word	0	# void
	.word	0	# void
	.word	0	# void
	.word	-1
Throw_protObj:
	.word	6	# class tag
	.word	3	# size
	.word	Throw_dispTab
	.word	-1
Op_protObj:
	.word	7	# class tag
	.word	3	# size
	.word	Op_dispTab
	.word	-1
Mylib_protObj:
	.word	8	# class tag
	.word	3	# size
	.word	Mylib_dispTab
	.word	-1
A2I_protObj:
	.word	9	# class tag
	.word	3	# size
	.word	A2I_dispTab
	.word	-1
Node_protObj:
	.word	10	# class tag
	.word	5	# size
	.word	Node_dispTab
	.word	0	# void
	.word	0	# void
	.word	-1
List_protObj:
	.word	11	# class tag
	.word	7	# size
	.word	List_dispTab
	.word	0	# void
	.word	0	# void
	.word	int_const4	# int(0)
	.word	str_const18	# str()
	.word	-1
Stack_protObj:
	.word	12	# class tag
	.word	7	# size
	.word	Stack_dispTab
	.word	0	# void
	.word	0	# void
	.word	int_const4	# int(0)
	.word	str_const18	# str()
	.word	-1
Queue_protObj:
	.word	13	# class tag
	.word	7	# size
	.word	Queue_dispTab
	.word	0	# void
	.word	0	# void
	.word	int_const4	# int(0)
	.word	str_const18	# str()
	.word	-1
BSTNode_protObj:
	.word	14	# class tag
	.word	7	# size
	.word	BSTNode_dispTab
	.word	0	# void
	.word	0	# void
	.word	0	# void
	.word	0	# void
	.word	-1
BST_protObj:
	.word	15	# class tag
	.word	6	# size
	.word	BST_dispTab
	.word	0	# void
	.word	str_const18	# str()
	.word	int_const4	# int(0)
	.word	-1
Entry_protObj:
	.word	16	# class tag
	.word	5	# size
	.word	Entry_dispTab
	.word	int_const4	# int(0)
	.word	str_const18	# str()
	.word	-1
HashTable_protObj:
	.word	17	# class tag
	.word	7	# size
	.word	HashTable_dispTab
	.word	0	# void
	.word	int_const4	# int(0)
	.word	int_const4	# int(0)
	.word	str_const18	# str()
#== generating global text ==
	.globl	heap_start
heap_start:
	.word	0
	.text
	.globl	Main_init
	.globl	Int_init
	.globl	String_init
	.globl	Bool_init
	.globl	Main.main
#== generating object initializers ==
Object_init:
#== save fp, s0, ra ==
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	addiu	$fp $sp 4

#^^^^^ fp now points to the return addr in stack ^^^^^

#== SELF = a0(ACC), set current object pointer ==
	move	$s0 $a0

#== Initializing 0 attributes for class: Object ==
	# ret = SELF
	move	$a0 $s0

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# return
	jr	$ra	

IO_init:
#== save fp, s0, ra ==
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	addiu	$fp $sp 4

#^^^^^ fp now points to the return addr in stack ^^^^^

#== SELF = a0(ACC), set current object pointer ==
	move	$s0 $a0

#== Calling parent init for class: IO, parent: Object ==
	jal	Object_init

#== Initializing 0 attributes for class: IO ==
	# ret = SELF
	move	$a0 $s0

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# return
	jr	$ra	

Int_init:
#== save fp, s0, ra ==
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	addiu	$fp $sp 4

#^^^^^ fp now points to the return addr in stack ^^^^^

#== SELF = a0(ACC), set current object pointer ==
	move	$s0 $a0

#== Calling parent init for class: Int, parent: Object ==
	jal	Object_init

#== Initializing 1 attributes for class: Int ==
#== Processing attribute: _val of type _prim_slot ==
	# init attrib _val
	# ret = SELF
	move	$a0 $s0

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# return
	jr	$ra	

Bool_init:
#== save fp, s0, ra ==
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	addiu	$fp $sp 4

#^^^^^ fp now points to the return addr in stack ^^^^^

#== SELF = a0(ACC), set current object pointer ==
	move	$s0 $a0

#== Calling parent init for class: Bool, parent: Object ==
	jal	Object_init

#== Initializing 1 attributes for class: Bool ==
#== Processing attribute: _val of type _prim_slot ==
	# init attrib _val
	# ret = SELF
	move	$a0 $s0

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# return
	jr	$ra	

String_init:
#== save fp, s0, ra ==
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	addiu	$fp $sp 4

#^^^^^ fp now points to the return addr in stack ^^^^^

#== SELF = a0(ACC), set current object pointer ==
	move	$s0 $a0

#== Calling parent init for class: String, parent: Object ==
	jal	Object_init

#== Initializing 2 attributes for class: String ==
#== Processing attribute: _val of type Int ==
	# init attrib _val
	la	$a0 int_const4
	sw	$a0 12($s0)
#== Processing attribute: _str_field of type _prim_slot ==
	# init attrib _str_field
	# ret = SELF
	move	$a0 $s0

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# return
	jr	$ra	

Main_init:
#== save fp, s0, ra ==
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	addiu	$fp $sp 4

#^^^^^ fp now points to the return addr in stack ^^^^^

#== SELF = a0(ACC), set current object pointer ==
	move	$s0 $a0

#== Calling parent init for class: Main, parent: IO ==
	jal	IO_init

#== Initializing 8 attributes for class: Main ==
#== Processing attribute: list1 of type List ==
	# init attrib list1
	# Dispatch. First eval and save the params.
	la	$a0 str_const1
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 List_protObj
	jal	Object.copy
	jal	List_init
	# if obj = void: abort
	bne	$a0 $zero label0
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label0:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 56($t1)

	# jumpto list_init
	jalr		$t1

	sw	$a0 12($s0)

#== Processing attribute: list2 of type List ==
	# init attrib list2
	# Dispatch. First eval and save the params.
	la	$a0 str_const2
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 List_protObj
	jal	Object.copy
	jal	List_init
	# if obj = void: abort
	bne	$a0 $zero label1
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label1:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 56($t1)

	# jumpto list_init
	jalr		$t1

	sw	$a0 16($s0)

#== Processing attribute: list3 of type List ==
	# init attrib list3
	# Dispatch. First eval and save the params.
	la	$a0 str_const3
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 List_protObj
	jal	Object.copy
	jal	List_init
	# if obj = void: abort
	bne	$a0 $zero label2
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label2:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 56($t1)

	# jumpto list_init
	jalr		$t1

	sw	$a0 20($s0)

#== Processing attribute: stack1 of type Stack ==
	# init attrib stack1
	# Dispatch. First eval and save the params.
	la	$a0 str_const4
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Stack_protObj
	jal	Object.copy
	jal	Stack_init
	# if obj = void: abort
	bne	$a0 $zero label3
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label3:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 100($t1)

	# jumpto stack_init
	jalr		$t1

	sw	$a0 24($s0)

#== Processing attribute: queue1 of type Queue ==
	# init attrib queue1
	# Dispatch. First eval and save the params.
	la	$a0 str_const5
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Queue_protObj
	jal	Object.copy
	jal	Queue_init
	# if obj = void: abort
	bne	$a0 $zero label4
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label4:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 100($t1)

	# jumpto queue_init
	jalr		$t1

	sw	$a0 28($s0)

#== Processing attribute: bst1 of type BST ==
	# init attrib bst1
	# Dispatch. First eval and save the params.
	la	$a0 str_const6
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 BST_protObj
	jal	Object.copy
	jal	BST_init
	# if obj = void: abort
	bne	$a0 $zero label5
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label5:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto bst_init
	jalr		$t1

	sw	$a0 32($s0)

#== Processing attribute: ht1 of type HashTable ==
	# init attrib ht1
	# Dispatch. First eval and save the params.
	la	$a0 str_const7
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	la	$a0 int_const0
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 HashTable_protObj
	jal	Object.copy
	jal	HashTable_init
	# if obj = void: abort
	bne	$a0 $zero label6
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label6:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto ht_init
	jalr		$t1

	sw	$a0 36($s0)

#== Processing attribute: dbg of type Mylib ==
	# init attrib dbg
	la	$a0 Mylib_protObj
	jal	Object.copy
	jal	Mylib_init
	sw	$a0 40($s0)

	# ret = SELF
	move	$a0 $s0

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# return
	jr	$ra	

Throw_init:
#== save fp, s0, ra ==
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	addiu	$fp $sp 4

#^^^^^ fp now points to the return addr in stack ^^^^^

#== SELF = a0(ACC), set current object pointer ==
	move	$s0 $a0

#== Calling parent init for class: Throw, parent: IO ==
	jal	IO_init

#== Initializing 0 attributes for class: Throw ==
	# ret = SELF
	move	$a0 $s0

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# return
	jr	$ra	

Op_init:
#== save fp, s0, ra ==
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	addiu	$fp $sp 4

#^^^^^ fp now points to the return addr in stack ^^^^^

#== SELF = a0(ACC), set current object pointer ==
	move	$s0 $a0

#== Calling parent init for class: Op, parent: Object ==
	jal	Object_init

#== Initializing 0 attributes for class: Op ==
	# ret = SELF
	move	$a0 $s0

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# return
	jr	$ra	

Mylib_init:
#== save fp, s0, ra ==
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	addiu	$fp $sp 4

#^^^^^ fp now points to the return addr in stack ^^^^^

#== SELF = a0(ACC), set current object pointer ==
	move	$s0 $a0

#== Calling parent init for class: Mylib, parent: IO ==
	jal	IO_init

#== Initializing 0 attributes for class: Mylib ==
	# ret = SELF
	move	$a0 $s0

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# return
	jr	$ra	

A2I_init:
#== save fp, s0, ra ==
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	addiu	$fp $sp 4

#^^^^^ fp now points to the return addr in stack ^^^^^

#== SELF = a0(ACC), set current object pointer ==
	move	$s0 $a0

#== Calling parent init for class: A2I, parent: Object ==
	jal	Object_init

#== Initializing 0 attributes for class: A2I ==
	# ret = SELF
	move	$a0 $s0

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# return
	jr	$ra	

Node_init:
#== save fp, s0, ra ==
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	addiu	$fp $sp 4

#^^^^^ fp now points to the return addr in stack ^^^^^

#== SELF = a0(ACC), set current object pointer ==
	move	$s0 $a0

#== Calling parent init for class: Node, parent: Object ==
	jal	Object_init

#== Initializing 2 attributes for class: Node ==
#== Processing attribute: next of type Node ==
	# init attrib next
#== Processing attribute: val of type Object ==
	# init attrib val
	# ret = SELF
	move	$a0 $s0

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# return
	jr	$ra	

List_init:
#== save fp, s0, ra ==
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	addiu	$fp $sp 4

#^^^^^ fp now points to the return addr in stack ^^^^^

#== SELF = a0(ACC), set current object pointer ==
	move	$s0 $a0

#== Calling parent init for class: List, parent: Node ==
	jal	Node_init

#== Initializing 2 attributes for class: List ==
#== Processing attribute: length of type Int ==
	# init attrib length
	la	$a0 int_const4
	sw	$a0 20($s0)

#== Processing attribute: name of type String ==
	# init attrib name
	la	$a0 str_const18
	sw	$a0 24($s0)
	# ret = SELF
	move	$a0 $s0

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# return
	jr	$ra	

Stack_init:
#== save fp, s0, ra ==
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	addiu	$fp $sp 4

#^^^^^ fp now points to the return addr in stack ^^^^^

#== SELF = a0(ACC), set current object pointer ==
	move	$s0 $a0

#== Calling parent init for class: Stack, parent: List ==
	jal	List_init

#== Initializing 0 attributes for class: Stack ==
	# ret = SELF
	move	$a0 $s0

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# return
	jr	$ra	

Queue_init:
#== save fp, s0, ra ==
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	addiu	$fp $sp 4

#^^^^^ fp now points to the return addr in stack ^^^^^

#== SELF = a0(ACC), set current object pointer ==
	move	$s0 $a0

#== Calling parent init for class: Queue, parent: List ==
	jal	List_init

#== Initializing 0 attributes for class: Queue ==
	# ret = SELF
	move	$a0 $s0

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# return
	jr	$ra	

BSTNode_init:
#== save fp, s0, ra ==
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	addiu	$fp $sp 4

#^^^^^ fp now points to the return addr in stack ^^^^^

#== SELF = a0(ACC), set current object pointer ==
	move	$s0 $a0

#== Calling parent init for class: BSTNode, parent: Node ==
	jal	Node_init

#== Initializing 2 attributes for class: BSTNode ==
#== Processing attribute: left of type BSTNode ==
	# init attrib left
#== Processing attribute: right of type BSTNode ==
	# init attrib right
	# ret = SELF
	move	$a0 $s0

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# return
	jr	$ra	

BST_init:
#== save fp, s0, ra ==
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	addiu	$fp $sp 4

#^^^^^ fp now points to the return addr in stack ^^^^^

#== SELF = a0(ACC), set current object pointer ==
	move	$s0 $a0

#== Calling parent init for class: BST, parent: Object ==
	jal	Object_init

#== Initializing 3 attributes for class: BST ==
#== Processing attribute: root of type BSTNode ==
	# init attrib root
#== Processing attribute: name of type String ==
	# init attrib name
	la	$a0 str_const18
	sw	$a0 16($s0)
#== Processing attribute: size of type Int ==
	# init attrib size
	la	$a0 int_const4
	sw	$a0 20($s0)

	# ret = SELF
	move	$a0 $s0

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# return
	jr	$ra	

Entry_init:
#== save fp, s0, ra ==
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	addiu	$fp $sp 4

#^^^^^ fp now points to the return addr in stack ^^^^^

#== SELF = a0(ACC), set current object pointer ==
	move	$s0 $a0

#== Calling parent init for class: Entry, parent: Object ==
	jal	Object_init

#== Initializing 2 attributes for class: Entry ==
#== Processing attribute: key of type Int ==
	# init attrib key
	la	$a0 int_const4
	sw	$a0 12($s0)
#== Processing attribute: value of type String ==
	# init attrib value
	la	$a0 str_const18
	sw	$a0 16($s0)
	# ret = SELF
	move	$a0 $s0

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# return
	jr	$ra	

HashTable_init:
#== save fp, s0, ra ==
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	addiu	$fp $sp 4

#^^^^^ fp now points to the return addr in stack ^^^^^

#== SELF = a0(ACC), set current object pointer ==
	move	$s0 $a0

#== Calling parent init for class: HashTable, parent: Object ==
	jal	Object_init

#== Initializing 4 attributes for class: HashTable ==
#== Processing attribute: buckets of type List ==
	# init attrib buckets
#== Processing attribute: capacity of type Int ==
	# init attrib capacity
	la	$a0 int_const4
	sw	$a0 16($s0)
#== Processing attribute: size of type Int ==
	# init attrib size
	la	$a0 int_const4
	sw	$a0 20($s0)

#== Processing attribute: name of type String ==
	# init attrib name
	la	$a0 str_const18
	sw	$a0 24($s0)
	# ret = SELF
	move	$a0 $s0

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# return
	jr	$ra	

#== generating class methods ==
Main.main:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Dispatch. First eval and save the params.
	la	$a0 str_const8
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label7
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label7:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const1
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label8
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label8:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 72($t1)

	# jumpto insert
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const9
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label9
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label9:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 72($t1)

	# jumpto insert
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const2
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label10
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label10:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 72($t1)

	# jumpto insert
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 bool_const1
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label11
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label11:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 72($t1)

	# jumpto insert
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const1
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	la	$a0 str_const9
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	la	$a0 int_const2
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	la	$a0 bool_const1
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 16($s0)

	# if obj = void: abort
	bne	$a0 $zero label12
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label12:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto linkBehind
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label13
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label13:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto linkBehind
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label14
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label14:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto linkBehind
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label15
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label15:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto linkBehind
	jalr		$t1

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	la	$a0 bool_const1
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	la	$a0 int_const2
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	la	$a0 str_const9
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	la	$a0 int_const1
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Node_protObj
	jal	Object.copy
	jal	Node_init
	# if obj = void: abort
	bne	$a0 $zero label16
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label16:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto node_init
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label17
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label17:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto linkBefore
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label18
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label18:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto linkBefore
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label19
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label19:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto linkBefore
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)

	# if obj = void: abort
	bne	$a0 $zero label20
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label20:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 44($t1)

	# jumpto linkBehindN
	jalr		$t1

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label21
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label21:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 52($t1)

	# jumpto print
	jalr		$t1

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 16($s0)

	# if obj = void: abort
	bne	$a0 $zero label22
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label22:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 52($t1)

	# jumpto print
	jalr		$t1

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)

	# if obj = void: abort
	bne	$a0 $zero label23
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label23:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 52($t1)

	# jumpto print
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const9
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label24
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label24:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 76($t1)

	# jumpto delete
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const3
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label25
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label25:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 76($t1)

	# jumpto delete
	jalr		$t1

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label26
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label26:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 52($t1)

	# jumpto print
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 bool_const0
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label27
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label27:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 88($t1)

	# jumpto length
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label28
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label28:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 60($t1)

	# jumpto insertIdx
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const10
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label29
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label29:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 88($t1)

	# jumpto length
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label30
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label30:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 60($t1)

	# jumpto insertIdx
	jalr		$t1

	# Dispatch. First eval and save the params.
	# Neg
	# Eval e1 and make a copy for result
	la	$a0 int_const5
	jal	Object.copy

	lw	$t1 12($a0)
	neg	$t1 $t1
	sw	$t1 12($a0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label31
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label31:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 88($t1)

	# jumpto length
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label32
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label32:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 60($t1)

	# jumpto insertIdx
	jalr		$t1

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label33
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label33:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 52($t1)

	# jumpto print
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const11
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	la	$a0 int_const3
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label34
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label34:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 80($t1)

	# jumpto search
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label35
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label35:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto debug
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const12
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	la	$a0 bool_const1
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label36
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label36:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 80($t1)

	# jumpto search
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label37
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label37:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto debug
	jalr		$t1

	# Dispatch. First eval and save the params.
	# Int operation : Sub
	# First eval e1 and push.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label38
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label38:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 88($t1)

	# jumpto length
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	sub	$t3 $t1 $t2
	sw	$t3 12($a0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label39
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label39:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 68($t1)

	# jumpto deleteIdx
	jalr		$t1

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label40
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label40:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 52($t1)

	# jumpto print
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const4
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label41
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label41:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 68($t1)

	# jumpto deleteIdx
	jalr		$t1

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label42
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label42:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 52($t1)

	# jumpto print
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const13
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	la	$a0 int_const4
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label43
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label43:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 92($t1)

	# jumpto valx
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label44
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label44:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto debug
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const14
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	la	$a0 int_const3
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label45
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label45:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 92($t1)

	# jumpto valx
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label46
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label46:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto debug
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const15
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label47
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label47:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 88($t1)

	# jumpto length
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label48
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label48:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 92($t1)

	# jumpto valx
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label49
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label49:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto debug
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const16
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label50
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label50:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 84($t1)

	# jumpto isEmpty
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label51
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label51:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto debug
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const17
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label52
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label52:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 88($t1)

	# jumpto length
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label53
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label53:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto debug
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const8
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label54
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label54:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const3
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 24($s0)

	# if obj = void: abort
	bne	$a0 $zero label55
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label55:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 104($t1)

	# jumpto push
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const9
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 24($s0)

	# if obj = void: abort
	bne	$a0 $zero label56
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label56:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 104($t1)

	# jumpto push
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 bool_const1
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 24($s0)

	# if obj = void: abort
	bne	$a0 $zero label57
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label57:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 104($t1)

	# jumpto push
	jalr		$t1

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 24($s0)

	# if obj = void: abort
	bne	$a0 $zero label58
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label58:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 52($t1)

	# jumpto print
	jalr		$t1

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 24($s0)

	# if obj = void: abort
	bne	$a0 $zero label59
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label59:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 112($t1)

	# jumpto peek
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label60
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label60:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto item2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label61
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label61:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 56($t1)

	# jumpto printtab
	jalr		$t1

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 24($s0)

	# if obj = void: abort
	bne	$a0 $zero label62
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label62:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 112($t1)

	# jumpto peek
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label63
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label63:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto item2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label64
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label64:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 56($t1)

	# jumpto printtab
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const18
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label65
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label65:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 60($t1)

	# jumpto println
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const19
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 24($s0)

	# if obj = void: abort
	bne	$a0 $zero label66
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label66:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 84($t1)

	# jumpto isEmpty
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label67
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label67:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto debug
	jalr		$t1

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 24($s0)

	# if obj = void: abort
	bne	$a0 $zero label68
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label68:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 52($t1)

	# jumpto print
	jalr		$t1

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 24($s0)

	# if obj = void: abort
	bne	$a0 $zero label69
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label69:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 108($t1)

	# jumpto pop
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label70
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label70:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto item2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label71
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label71:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 56($t1)

	# jumpto printtab
	jalr		$t1

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 24($s0)

	# if obj = void: abort
	bne	$a0 $zero label72
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label72:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 108($t1)

	# jumpto pop
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label73
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label73:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto item2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label74
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label74:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 56($t1)

	# jumpto printtab
	jalr		$t1

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 24($s0)

	# if obj = void: abort
	bne	$a0 $zero label75
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label75:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 108($t1)

	# jumpto pop
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label76
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label76:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto item2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label77
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label77:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 56($t1)

	# jumpto printtab
	jalr		$t1

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 24($s0)

	# if obj = void: abort
	bne	$a0 $zero label78
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label78:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 108($t1)

	# jumpto pop
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label79
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label79:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto item2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label80
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label80:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 56($t1)

	# jumpto printtab
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const19
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 24($s0)

	# if obj = void: abort
	bne	$a0 $zero label81
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label81:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 84($t1)

	# jumpto isEmpty
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label82
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label82:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto debug
	jalr		$t1

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 24($s0)

	# if obj = void: abort
	bne	$a0 $zero label83
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label83:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 52($t1)

	# jumpto print
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const8
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label84
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label84:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const3
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 28($s0)

	# if obj = void: abort
	bne	$a0 $zero label85
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label85:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 104($t1)

	# jumpto enqueue
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const9
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 28($s0)

	# if obj = void: abort
	bne	$a0 $zero label86
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label86:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 104($t1)

	# jumpto enqueue
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 bool_const1
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 28($s0)

	# if obj = void: abort
	bne	$a0 $zero label87
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label87:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 104($t1)

	# jumpto enqueue
	jalr		$t1

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 28($s0)

	# if obj = void: abort
	bne	$a0 $zero label88
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label88:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 52($t1)

	# jumpto print
	jalr		$t1

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 28($s0)

	# if obj = void: abort
	bne	$a0 $zero label89
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label89:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 112($t1)

	# jumpto front
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label90
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label90:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto item2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label91
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label91:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 56($t1)

	# jumpto printtab
	jalr		$t1

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 28($s0)

	# if obj = void: abort
	bne	$a0 $zero label92
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label92:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 112($t1)

	# jumpto front
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label93
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label93:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto item2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label94
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label94:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 56($t1)

	# jumpto printtab
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const18
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label95
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label95:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 60($t1)

	# jumpto println
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const20
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 28($s0)

	# if obj = void: abort
	bne	$a0 $zero label96
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label96:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 84($t1)

	# jumpto isEmpty
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label97
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label97:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto debug
	jalr		$t1

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 28($s0)

	# if obj = void: abort
	bne	$a0 $zero label98
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label98:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 52($t1)

	# jumpto print
	jalr		$t1

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 28($s0)

	# if obj = void: abort
	bne	$a0 $zero label99
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label99:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 108($t1)

	# jumpto dequeue
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label100
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label100:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto item2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label101
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label101:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 56($t1)

	# jumpto printtab
	jalr		$t1

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 28($s0)

	# if obj = void: abort
	bne	$a0 $zero label102
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label102:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 108($t1)

	# jumpto dequeue
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label103
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label103:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto item2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label104
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label104:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 56($t1)

	# jumpto printtab
	jalr		$t1

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 28($s0)

	# if obj = void: abort
	bne	$a0 $zero label105
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label105:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 108($t1)

	# jumpto dequeue
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label106
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label106:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto item2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label107
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label107:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 56($t1)

	# jumpto printtab
	jalr		$t1

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 28($s0)

	# if obj = void: abort
	bne	$a0 $zero label108
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label108:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 108($t1)

	# jumpto dequeue
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label109
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label109:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto item2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label110
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label110:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 56($t1)

	# jumpto printtab
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const20
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 28($s0)

	# if obj = void: abort
	bne	$a0 $zero label111
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label111:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 84($t1)

	# jumpto isEmpty
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label112
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label112:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto debug
	jalr		$t1

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 28($s0)

	# if obj = void: abort
	bne	$a0 $zero label113
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label113:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 52($t1)

	# jumpto print
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const8
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label114
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label114:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const6
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 32($s0)

	# if obj = void: abort
	bne	$a0 $zero label115
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label115:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto insert
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const7
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 32($s0)

	# if obj = void: abort
	bne	$a0 $zero label116
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label116:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto insert
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const8
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 32($s0)

	# if obj = void: abort
	bne	$a0 $zero label117
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label117:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto insert
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const9
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 32($s0)

	# if obj = void: abort
	bne	$a0 $zero label118
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label118:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto insert
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const10
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 32($s0)

	# if obj = void: abort
	bne	$a0 $zero label119
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label119:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto insert
	jalr		$t1

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 32($s0)

	# if obj = void: abort
	bne	$a0 $zero label120
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label120:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 48($t1)

	# jumpto printInOrder
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const21
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	la	$a0 int_const3
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 32($s0)

	# if obj = void: abort
	bne	$a0 $zero label121
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label121:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto search
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label122
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label122:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto debug
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const22
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	la	$a0 int_const7
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 32($s0)

	# if obj = void: abort
	bne	$a0 $zero label123
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label123:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto search
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label124
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label124:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto debug
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const23
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	la	$a0 int_const9
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 32($s0)

	# if obj = void: abort
	bne	$a0 $zero label125
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label125:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto search
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label126
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label126:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto debug
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const8
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label127
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label127:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const4
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	la	$a0 str_const24
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 36($s0)

	# if obj = void: abort
	bne	$a0 $zero label128
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label128:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto put
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const3
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	la	$a0 str_const25
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 36($s0)

	# if obj = void: abort
	bne	$a0 $zero label129
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label129:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto put
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const11
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	la	$a0 str_const26
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 36($s0)

	# if obj = void: abort
	bne	$a0 $zero label130
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label130:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto put
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const0
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	la	$a0 str_const27
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 36($s0)

	# if obj = void: abort
	bne	$a0 $zero label131
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label131:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto put
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const12
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	la	$a0 str_const28
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 36($s0)

	# if obj = void: abort
	bne	$a0 $zero label132
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label132:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto put
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const13
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	la	$a0 str_const29
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 36($s0)

	# if obj = void: abort
	bne	$a0 $zero label133
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label133:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto put
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const14
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	la	$a0 str_const30
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 36($s0)

	# if obj = void: abort
	bne	$a0 $zero label134
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label134:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto put
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const15
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	la	$a0 str_const31
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 36($s0)

	# if obj = void: abort
	bne	$a0 $zero label135
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label135:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto put
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const16
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	la	$a0 str_const32
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 36($s0)

	# if obj = void: abort
	bne	$a0 $zero label136
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label136:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto put
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const11
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	la	$a0 str_const33
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 36($s0)

	# if obj = void: abort
	bne	$a0 $zero label137
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label137:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto put
	jalr		$t1

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 36($s0)

	# if obj = void: abort
	bne	$a0 $zero label138
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label138:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 40($t1)

	# jumpto print
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const34
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	la	$a0 int_const0
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 36($s0)

	# if obj = void: abort
	bne	$a0 $zero label139
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label139:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto get
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label140
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label140:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto debug
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const35
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	la	$a0 int_const11
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 36($s0)

	# if obj = void: abort
	bne	$a0 $zero label141
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label141:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto get
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label142
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label142:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto debug
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const36
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	la	$a0 int_const17
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 36($s0)

	# if obj = void: abort
	bne	$a0 $zero label143
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label143:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto get
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 40($s0)

	# if obj = void: abort
	bne	$a0 $zero label144
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label144:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto debug
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const4
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 36($s0)

	# if obj = void: abort
	bne	$a0 $zero label145
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label145:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto remove
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const11
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 36($s0)

	# if obj = void: abort
	bne	$a0 $zero label146
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label146:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto remove
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 int_const15
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 36($s0)

	# if obj = void: abort
	bne	$a0 $zero label147
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label147:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto remove
	jalr		$t1

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 36($s0)

	# if obj = void: abort
	bne	$a0 $zero label148
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label148:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 40($t1)

	# jumpto print
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const8
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label149
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label149:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

Throw.error:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Dispatch. First eval and save the params.
	la	$a0 str_const39
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	la	$a0 str_const38
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label150
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label150:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label151
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label151:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label152
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label152:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label153
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label153:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 0($t1)

	# jumpto abort
	jalr		$t1


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Throw.warning:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Dispatch. First eval and save the params.
	la	$a0 str_const39
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	la	$a0 str_const40
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label154
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label154:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label155
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label155:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label156
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label156:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Op.and:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label157

	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# jumpt finish
	b	label158

# False:
label157:
	la	$a0 bool_const0
# Finish:
label158:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 8

	# return
	jr	$ra	

Op.or:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label159

	la	$a0 bool_const1
	# jumpt finish
	b	label160

# False:
label159:
	# Object:
	# It is a param.
	lw	$a0 12($fp)

# Finish:
label160:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 8

	# return
	jr	$ra	

Op.xor:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label161

	# If statement. First eval condition.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label163

	la	$a0 bool_const0
	# jumpt finish
	b	label164

# False:
label163:
	la	$a0 bool_const1
# Finish:
label164:
	# jumpt finish
	b	label162

# False:
label161:
	# If statement. First eval condition.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label165

	la	$a0 bool_const1
	# jumpt finish
	b	label166

# False:
label165:
	la	$a0 bool_const0
# Finish:
label166:
# Finish:
label162:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 8

	# return
	jr	$ra	

Op.mod:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Int operation : Less or equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const4

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	ble	$t1 $t2 label167
	la	$a0 bool_const0
label167:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label168

	# Dispatch. First eval and save the params.
	la	$a0 str_const41
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label170
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label170:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto error
	jalr		$t1

	la	$a0 int_const4
	# jumpt finish
	b	label169

# False:
label168:
	# Let expr
	# First eval init
	# Int operation : Div
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	div	$t3 $t1 $t2
	sw	$t3 12($a0)

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# If statement. First eval condition.
	# Dispatch. First eval and save the params.
	# Int operation : Less than
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const4

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	blt	$t1 $t2 label171
	la	$a0 bool_const0
label171:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# the 'not' operator
	# First eval the bool
	# equal
	# First eval e1 and push.
	# Int operation : Sub
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	# Int operation : Mul
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 12($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	mul	$t3 $t1 $t2
	sw	$t3 12($a0)

	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	sub	$t3 $t1 $t2
	sw	$t3 12($a0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const4

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label172
	# Load false
	la	$a0 bool_const0
	# finish:
label172:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label173
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label173:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto and
	jalr		$t1

	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label174

#== Assign. First eval the expr ==
	# Int operation : Sub
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	sub	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 4($sp)
	# jumpt finish
	b	label175

# False:
label174:
	la	$a0 int_const4
# Finish:
label175:
	# Int operation : Sub
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	# Int operation : Mul
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	mul	$t3 $t1 $t2
	sw	$t3 12($a0)

	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	sub	$t3 $t1 $t2
	sw	$t3 12($a0)

	# pop
	addiu	$sp $sp 4

# Finish:
label169:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 8

	# return
	jr	$ra	

Mylib.i2b:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# the 'not' operator
	# First eval the bool
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const4

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label176
	# Load false
	la	$a0 bool_const0
	# finish:
label176:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label177

	la	$a0 bool_const1
	# jumpt finish
	b	label178

# False:
label177:
	la	$a0 bool_const0
# Finish:
label178:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Mylib.b2a:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label179

	la	$a0 str_const42
	# jumpt finish
	b	label180

# False:
label179:
	la	$a0 str_const43
# Finish:
label180:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Mylib.item2a:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label181

	# acc != void
	la	$a0 bool_const0
# finish:
label181:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label182

	# Dispatch. First eval and save the params.
	la	$a0 str_const44
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label184
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label184:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto error
	jalr		$t1

	la	$a0 str_const18
	# jumpt finish
	b	label183

# False:
label182:
	# case expr
	# First eval e0
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# If e0 = void, abort
	bne	$a0 $zero label185
	la	$a0 str_const0
	li	$t1 1
	jal	_case_abort2
label185:
	# T1 = type(acc)
	lw	$t1 0($a0)
	# tag = 4 : goto case 0
	li	$t2 4
	beq	$t1 $t2 label186

	# tag = 2 : goto case 1
	li	$t2 2
	beq	$t1 $t2 label187

	# tag = 3 : goto case 2
	li	$t2 3
	beq	$t1 $t2 label188

	# tag = 0 : goto case 3
	li	$t2 0
	beq	$t1 $t2 label189

	# ----------------
	# tag = 1 : goto case 3
	li	$t2 1
	beq	$t1 $t2 label189

	# tag = 2 : goto case 3
	li	$t2 2
	beq	$t1 $t2 label189

	# tag = 3 : goto case 3
	li	$t2 3
	beq	$t1 $t2 label189

	# tag = 4 : goto case 3
	li	$t2 4
	beq	$t1 $t2 label189

	# tag = 7 : goto case 3
	li	$t2 7
	beq	$t1 $t2 label189

	# tag = 9 : goto case 3
	li	$t2 9
	beq	$t1 $t2 label189

	# tag = 10 : goto case 3
	li	$t2 10
	beq	$t1 $t2 label189

	# tag = 15 : goto case 3
	li	$t2 15
	beq	$t1 $t2 label189

	# tag = 16 : goto case 3
	li	$t2 16
	beq	$t1 $t2 label189

	# tag = 17 : goto case 3
	li	$t2 17
	beq	$t1 $t2 label189

	# ----------------
	# tag = 5 : goto case 3
	li	$t2 5
	beq	$t1 $t2 label189

	# tag = 6 : goto case 3
	li	$t2 6
	beq	$t1 $t2 label189

	# tag = 8 : goto case 3
	li	$t2 8
	beq	$t1 $t2 label189

	# tag = 11 : goto case 3
	li	$t2 11
	beq	$t1 $t2 label189

	# tag = 14 : goto case 3
	li	$t2 14
	beq	$t1 $t2 label189

	# ----------------
	# tag = 12 : goto case 3
	li	$t2 12
	beq	$t1 $t2 label189

	# tag = 13 : goto case 3
	li	$t2 13
	beq	$t1 $t2 label189

	# ----------------
	# No match
	jal	_case_abort
	b	label190
# eval expr 0
label186:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	addiu	$sp $sp 4
	# Jumpto finish
	b	label190
# eval expr 1
label187:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 A2I_protObj
	jal	Object.copy
	jal	A2I_init
	# if obj = void: abort
	bne	$a0 $zero label191
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label191:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto i2a
	jalr		$t1

	addiu	$sp $sp 4
	# Jumpto finish
	b	label190
# eval expr 2
label188:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label192
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label192:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto b2a
	jalr		$t1

	addiu	$sp $sp 4
	# Jumpto finish
	b	label190
# eval expr 3
label189:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	la	$a0 str_const45
	addiu	$sp $sp 4
	# Jumpto finish
	b	label190
#finish:
label190:

# Finish:
label183:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Mylib.item2i:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label193

	# acc != void
	la	$a0 bool_const0
# finish:
label193:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label194

	# Dispatch. First eval and save the params.
	la	$a0 str_const46
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label196
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label196:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto error
	jalr		$t1

	la	$a0 int_const4
	# jumpt finish
	b	label195

# False:
label194:
	# case expr
	# First eval e0
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# If e0 = void, abort
	bne	$a0 $zero label197
	la	$a0 str_const0
	li	$t1 1
	jal	_case_abort2
label197:
	# T1 = type(acc)
	lw	$t1 0($a0)
	# tag = 2 : goto case 0
	li	$t2 2
	beq	$t1 $t2 label198

	# ----------------
	# No match
	jal	_case_abort
	b	label199
# eval expr 0
label198:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	addiu	$sp $sp 4
	# Jumpto finish
	b	label199
#finish:
label199:

# Finish:
label195:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Mylib.item2s:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label200

	# acc != void
	la	$a0 bool_const0
# finish:
label200:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label201

	# Dispatch. First eval and save the params.
	la	$a0 str_const46
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label203
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label203:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto error
	jalr		$t1

	la	$a0 str_const18
	# jumpt finish
	b	label202

# False:
label201:
	# case expr
	# First eval e0
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# If e0 = void, abort
	bne	$a0 $zero label204
	la	$a0 str_const0
	li	$t1 1
	jal	_case_abort2
label204:
	# T1 = type(acc)
	lw	$t1 0($a0)
	# tag = 4 : goto case 0
	li	$t2 4
	beq	$t1 $t2 label205

	# ----------------
	# No match
	jal	_case_abort
	b	label206
# eval expr 0
label205:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	addiu	$sp $sp 4
	# Jumpto finish
	b	label206
#finish:
label206:

# Finish:
label202:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Mylib.item2b:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label207

	# acc != void
	la	$a0 bool_const0
# finish:
label207:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label208

	# Dispatch. First eval and save the params.
	la	$a0 str_const46
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label210
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label210:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto error
	jalr		$t1

	la	$a0 bool_const0
	# jumpt finish
	b	label209

# False:
label208:
	# case expr
	# First eval e0
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# If e0 = void, abort
	bne	$a0 $zero label211
	la	$a0 str_const0
	li	$t1 1
	jal	_case_abort2
label211:
	# T1 = type(acc)
	lw	$t1 0($a0)
	# tag = 3 : goto case 0
	li	$t2 3
	beq	$t1 $t2 label212

	# ----------------
	# No match
	jal	_case_abort
	b	label213
# eval expr 0
label212:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	addiu	$sp $sp 4
	# Jumpto finish
	b	label213
#finish:
label213:

# Finish:
label209:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Mylib.printspc:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Dispatch. First eval and save the params.
	la	$a0 str_const47
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label214
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label214:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label215
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label215:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Mylib.printtab:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Dispatch. First eval and save the params.
	la	$a0 str_const48
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label216
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label216:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label217
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label217:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Mylib.println:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Dispatch. First eval and save the params.
	la	$a0 str_const49
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label218
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label218:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label219
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label219:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Mylib.debug:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Dispatch. First eval and save the params.
	la	$a0 str_const49
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label220
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label220:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto item2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	la	$a0 str_const50
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label221
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label221:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label222
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label222:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label223
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label223:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label224
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label224:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 8

	# return
	jr	$ra	

A2I.c2i:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 str_const51

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label225

	la	$a0 int_const4
	# jumpt finish
	b	label226

# False:
label225:
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 str_const52

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label227

	la	$a0 int_const3
	# jumpt finish
	b	label228

# False:
label227:
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 str_const53

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label229

	la	$a0 int_const11
	# jumpt finish
	b	label230

# False:
label229:
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 str_const54

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label231

	la	$a0 int_const0
	# jumpt finish
	b	label232

# False:
label231:
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 str_const55

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label233

	la	$a0 int_const12
	# jumpt finish
	b	label234

# False:
label233:
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 str_const56

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label235

	la	$a0 int_const13
	# jumpt finish
	b	label236

# False:
label235:
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 str_const57

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label237

	la	$a0 int_const14
	# jumpt finish
	b	label238

# False:
label237:
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 str_const58

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label239

	la	$a0 int_const15
	# jumpt finish
	b	label240

# False:
label239:
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 str_const59

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label241

	la	$a0 int_const16
	# jumpt finish
	b	label242

# False:
label241:
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 str_const60

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label243

	la	$a0 int_const18
	# jumpt finish
	b	label244

# False:
label243:
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label245
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label245:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 0($t1)

	# jumpto abort
	jalr		$t1

	la	$a0 int_const4
# Finish:
label244:
# Finish:
label242:
# Finish:
label240:
# Finish:
label238:
# Finish:
label236:
# Finish:
label234:
# Finish:
label232:
# Finish:
label230:
# Finish:
label228:
# Finish:
label226:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

A2I.i2c:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const4

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label246

	la	$a0 str_const51
	# jumpt finish
	b	label247

# False:
label246:
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const3

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label248

	la	$a0 str_const52
	# jumpt finish
	b	label249

# False:
label248:
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const11

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label250

	la	$a0 str_const53
	# jumpt finish
	b	label251

# False:
label250:
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const0

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label252

	la	$a0 str_const54
	# jumpt finish
	b	label253

# False:
label252:
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const12

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label254

	la	$a0 str_const55
	# jumpt finish
	b	label255

# False:
label254:
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const13

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label256

	la	$a0 str_const56
	# jumpt finish
	b	label257

# False:
label256:
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const14

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label258

	la	$a0 str_const57
	# jumpt finish
	b	label259

# False:
label258:
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const15

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label260

	la	$a0 str_const58
	# jumpt finish
	b	label261

# False:
label260:
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const16

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label262

	la	$a0 str_const59
	# jumpt finish
	b	label263

# False:
label262:
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const18

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label264

	la	$a0 str_const60
	# jumpt finish
	b	label265

# False:
label264:
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label266
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label266:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 0($t1)

	# jumpto abort
	jalr		$t1

	la	$a0 str_const18
# Finish:
label265:
# Finish:
label263:
# Finish:
label261:
# Finish:
label259:
# Finish:
label257:
# Finish:
label255:
# Finish:
label253:
# Finish:
label251:
# Finish:
label249:
# Finish:
label247:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

A2I.a2i:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label267
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label267:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto length
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const4

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label268

	la	$a0 int_const4
	# jumpt finish
	b	label269

# False:
label268:
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Dispatch. First eval and save the params.
	la	$a0 int_const4
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	la	$a0 int_const3
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label270
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label270:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 20($t1)

	# jumpto substr
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 str_const61

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label271

	# Neg
	# Eval e1 and make a copy for result
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	la	$a0 int_const3
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Int operation : Sub
	# First eval e1 and push.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label273
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label273:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto length
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	sub	$t3 $t1 $t2
	sw	$t3 12($a0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label274
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label274:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 20($t1)

	# jumpto substr
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label275
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label275:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto a2i_aux
	jalr		$t1

	jal	Object.copy

	lw	$t1 12($a0)
	neg	$t1 $t1
	sw	$t1 12($a0)

	# jumpt finish
	b	label272

# False:
label271:
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Dispatch. First eval and save the params.
	la	$a0 int_const4
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	la	$a0 int_const3
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label276
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label276:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 20($t1)

	# jumpto substr
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 str_const62

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label277

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	la	$a0 int_const3
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Int operation : Sub
	# First eval e1 and push.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label279
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label279:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto length
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	sub	$t3 $t1 $t2
	sw	$t3 12($a0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label280
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label280:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 20($t1)

	# jumpto substr
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label281
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label281:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto a2i_aux
	jalr		$t1

	# jumpt finish
	b	label278

# False:
label277:
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label282
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label282:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto a2i_aux
	jalr		$t1

# Finish:
label278:
# Finish:
label272:
# Finish:
label269:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

A2I.a2i_aux:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Let expr
	# First eval init
	la	$a0 int_const4
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label283
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label283:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto length
	jalr		$t1

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	la	$a0 int_const4
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# While loop
	# start:
label284:
	# ACC = pred
	# Int operation : Less than
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is a let variable.
	lw	$a0 12($sp)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	blt	$t1 $t2 label286
	la	$a0 bool_const0
label286:
	# extract int inside bool
	lw	$t1 12($a0)

	# if pred == false jumpto finish
	beq	$t1 $zero label285

#== Assign. First eval the expr ==
	# Int operation : Add
	# First eval e1 and push.
	# Int operation : Mul
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 12($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const17
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	mul	$t3 $t1 $t2
	sw	$t3 12($a0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	la	$a0 int_const3
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label287
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label287:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 20($t1)

	# jumpto substr
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label288
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label288:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto c2i
	jalr		$t1

	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	add	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 12($sp)
#== Assign. First eval the expr ==
	# Int operation : Add
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	add	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 4($sp)
	# Jumpto start
	b	label284
	# Finish:
label285:
	# ACC = void
	move	$a0 $zero
	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4

	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# pop
	addiu	$sp $sp 4


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

A2I.i2a:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const4

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label289

	la	$a0 str_const51
	# jumpt finish
	b	label290

# False:
label289:
	# If statement. First eval condition.
	# Int operation : Less than
	# First eval e1 and push.
	la	$a0 int_const4
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is a param.
	lw	$a0 12($fp)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	blt	$t1 $t2 label291
	la	$a0 bool_const0
label291:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label292

	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label294
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label294:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto i2a_aux
	jalr		$t1

	# jumpt finish
	b	label293

# False:
label292:
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Int operation : Mul
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	# Neg
	# Eval e1 and make a copy for result
	la	$a0 int_const3
	jal	Object.copy

	lw	$t1 12($a0)
	neg	$t1 $t1
	sw	$t1 12($a0)

	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	mul	$t3 $t1 $t2
	sw	$t3 12($a0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label295
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label295:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto i2a_aux
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 str_const61
	# if obj = void: abort
	bne	$a0 $zero label296
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label296:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto concat
	jalr		$t1

# Finish:
label293:
# Finish:
label290:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

A2I.i2a_aux:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const4

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label297

	la	$a0 str_const18
	# jumpt finish
	b	label298

# False:
label297:
	# Let expr
	# First eval init
	# Int operation : Div
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const17
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	div	$t3 $t1 $t2
	sw	$t3 12($a0)

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Int operation : Sub
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	# Int operation : Mul
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const17
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	mul	$t3 $t1 $t2
	sw	$t3 12($a0)

	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	sub	$t3 $t1 $t2
	sw	$t3 12($a0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label299
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label299:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto i2c
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label300
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label300:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto i2a_aux
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label301
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label301:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto concat
	jalr		$t1

	# pop
	addiu	$sp $sp 4

# Finish:
label298:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Node.node_init:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label302

	# acc != void
	la	$a0 bool_const0
# finish:
label302:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label303

	# Dispatch. First eval and save the params.
	la	$a0 str_const64
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label305
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label305:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto error
	jalr		$t1

	# Object:
	# It is self.
	move	$a0 $s0

	# jumpt finish
	b	label304

# False:
label303:
#== Assign. First eval the expr ==
	# Object:
	# It is a param.
	lw	$a0 12($fp)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 16($s0)
	# Object:
	# It is self.
	move	$a0 $s0

# Finish:
label304:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Node.link:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
#== Assign. First eval the expr ==
	# Object:
	# It is a param.
	lw	$a0 12($fp)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 12($s0)

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Node.assign:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label306

	# acc != void
	la	$a0 bool_const0
# finish:
label306:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label307

	# Dispatch. First eval and save the params.
	la	$a0 str_const65
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label309
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label309:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto warning
	jalr		$t1

	# jumpt finish
	b	label308

# False:
label307:
#== Assign. First eval the expr ==
	# Object:
	# It is a param.
	lw	$a0 12($fp)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 16($s0)
# Finish:
label308:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Node.next:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

Node.val:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Object:
	# It is an attribute.
	lw	$a0 16($s0)


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

Node.linkBefore:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Let expr
	# First eval init
	la	$a0 Node_protObj
	jal	Object.copy
	jal	Node_init
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Dispatch. First eval and save the params.
	# Object:
	# It is self.
	move	$a0 $s0

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label310
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label310:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto link
	jalr		$t1

	# If statement. First eval condition.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label311

	# acc != void
	la	$a0 bool_const0
# finish:
label311:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label312

	# Dispatch. First eval and save the params.
	la	$a0 str_const66
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label314
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label314:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto warning
	jalr		$t1

	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# jumpt finish
	b	label313

# False:
label312:
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label315
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label315:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 20($t1)

	# jumpto assign
	jalr		$t1

	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

# Finish:
label313:
	# pop
	addiu	$sp $sp 4


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Node.linkBehind:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Let expr
	# First eval init
	la	$a0 Node_protObj
	jal	Object.copy
	jal	Node_init
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

#== Assign. First eval the expr ==
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 12($s0)
	# If statement. First eval condition.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label316

	# acc != void
	la	$a0 bool_const0
# finish:
label316:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label317

	# Dispatch. First eval and save the params.
	la	$a0 str_const67
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label319
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label319:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto warning
	jalr		$t1

	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# jumpt finish
	b	label318

# False:
label317:
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label320
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label320:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 20($t1)

	# jumpto assign
	jalr		$t1

	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

# Finish:
label318:
	# pop
	addiu	$sp $sp 4


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Node.linkBeforeN:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label321

	# acc != void
	la	$a0 bool_const0
# finish:
label321:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label322

	# Dispatch. First eval and save the params.
	la	$a0 str_const68
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label324
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label324:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto warning
	jalr		$t1

	# Object:
	# It is self.
	move	$a0 $s0

	# jumpt finish
	b	label323

# False:
label322:
	# Dispatch. First eval and save the params.
	# Object:
	# It is self.
	move	$a0 $s0

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label325
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label325:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto link
	jalr		$t1

	# Object:
	# It is a param.
	lw	$a0 12($fp)

# Finish:
label323:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Node.linkBehindN:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label326

	# acc != void
	la	$a0 bool_const0
# finish:
label326:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label327

	# Dispatch. First eval and save the params.
	la	$a0 str_const69
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label329
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label329:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto warning
	jalr		$t1

	# Object:
	# It is self.
	move	$a0 $s0

	# jumpt finish
	b	label328

# False:
label327:
#== Assign. First eval the expr ==
	# Object:
	# It is a param.
	lw	$a0 12($fp)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 12($s0)
	# Object:
	# It is a param.
	lw	$a0 12($fp)

# Finish:
label328:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Node.deleteBehind:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label330

	# acc != void
	la	$a0 bool_const0
# finish:
label330:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label331

	# Dispatch. First eval and save the params.
	la	$a0 str_const70
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label333
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label333:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto warning
	jalr		$t1

	# Object:
	# It is self.
	move	$a0 $s0

	# jumpt finish
	b	label332

# False:
label331:
#== Assign. First eval the expr ==
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label334
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label334:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto next
	jalr		$t1

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 12($s0)
	# Object:
	# It is self.
	move	$a0 $s0

# Finish:
label332:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

Node.print:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# case expr
	# First eval e0
	# Object:
	# It is an attribute.
	lw	$a0 16($s0)

	# If e0 = void, abort
	bne	$a0 $zero label335
	la	$a0 str_const0
	li	$t1 1
	jal	_case_abort2
label335:
	# T1 = type(acc)
	lw	$t1 0($a0)
	# tag = 4 : goto case 0
	li	$t2 4
	beq	$t1 $t2 label336

	# tag = 2 : goto case 1
	li	$t2 2
	beq	$t1 $t2 label337

	# tag = 3 : goto case 2
	li	$t2 3
	beq	$t1 $t2 label338

	# tag = 0 : goto case 3
	li	$t2 0
	beq	$t1 $t2 label339

	# ----------------
	# tag = 1 : goto case 3
	li	$t2 1
	beq	$t1 $t2 label339

	# tag = 2 : goto case 3
	li	$t2 2
	beq	$t1 $t2 label339

	# tag = 3 : goto case 3
	li	$t2 3
	beq	$t1 $t2 label339

	# tag = 4 : goto case 3
	li	$t2 4
	beq	$t1 $t2 label339

	# tag = 7 : goto case 3
	li	$t2 7
	beq	$t1 $t2 label339

	# tag = 9 : goto case 3
	li	$t2 9
	beq	$t1 $t2 label339

	# tag = 10 : goto case 3
	li	$t2 10
	beq	$t1 $t2 label339

	# tag = 15 : goto case 3
	li	$t2 15
	beq	$t1 $t2 label339

	# tag = 16 : goto case 3
	li	$t2 16
	beq	$t1 $t2 label339

	# tag = 17 : goto case 3
	li	$t2 17
	beq	$t1 $t2 label339

	# ----------------
	# tag = 5 : goto case 3
	li	$t2 5
	beq	$t1 $t2 label339

	# tag = 6 : goto case 3
	li	$t2 6
	beq	$t1 $t2 label339

	# tag = 8 : goto case 3
	li	$t2 8
	beq	$t1 $t2 label339

	# tag = 11 : goto case 3
	li	$t2 11
	beq	$t1 $t2 label339

	# tag = 14 : goto case 3
	li	$t2 14
	beq	$t1 $t2 label339

	# ----------------
	# tag = 12 : goto case 3
	li	$t2 12
	beq	$t1 $t2 label339

	# tag = 13 : goto case 3
	li	$t2 13
	beq	$t1 $t2 label339

	# ----------------
	# No match
	jal	_case_abort
	b	label340
# eval expr 0
label336:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	la	$a0 str_const71
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 IO_protObj
	jal	Object.copy
	jal	IO_init
	# if obj = void: abort
	bne	$a0 $zero label341
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label341:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label342
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label342:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	addiu	$sp $sp 4
	# Jumpto finish
	b	label340
# eval expr 1
label337:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	la	$a0 str_const71
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 A2I_protObj
	jal	Object.copy
	jal	A2I_init
	# if obj = void: abort
	bne	$a0 $zero label343
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label343:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto i2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 IO_protObj
	jal	Object.copy
	jal	IO_init
	# if obj = void: abort
	bne	$a0 $zero label344
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label344:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label345
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label345:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	addiu	$sp $sp 4
	# Jumpto finish
	b	label340
# eval expr 2
label338:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	la	$a0 str_const71
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Mylib_protObj
	jal	Object.copy
	jal	Mylib_init
	# if obj = void: abort
	bne	$a0 $zero label346
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label346:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto b2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 IO_protObj
	jal	Object.copy
	jal	IO_init
	# if obj = void: abort
	bne	$a0 $zero label347
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label347:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label348
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label348:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	addiu	$sp $sp 4
	# Jumpto finish
	b	label340
# eval expr 3
label339:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	la	$a0 str_const72
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 IO_protObj
	jal	Object.copy
	jal	IO_init
	# if obj = void: abort
	bne	$a0 $zero label349
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label349:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	addiu	$sp $sp 4
	# Jumpto finish
	b	label340
#finish:
label340:


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

List.list_init:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
#== Assign. First eval the expr ==
	# Object:
	# It is a param.
	lw	$a0 12($fp)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 24($s0)
#== Assign. First eval the expr ==
	la	$a0 str_const73
#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 16($s0)
	# Object:
	# It is self.
	move	$a0 $s0


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

List.insertIdx:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Dispatch. First eval and save the params.
	# the 'not' operator
	# First eval the bool
	# Int operation : Less or equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	ble	$t1 $t2 label350
	la	$a0 bool_const0
label350:
	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label351
	# Load false
	la	$a0 bool_const0
	# finish:
label351:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Int operation : Less than
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const4

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	blt	$t1 $t2 label352
	la	$a0 bool_const0
label352:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Op_protObj
	jal	Object.copy
	jal	Op_init
	# if obj = void: abort
	bne	$a0 $zero label353
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label353:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto or
	jalr		$t1

	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label354

	# Dispatch. First eval and save the params.
	la	$a0 str_const74
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label356
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label356:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto warning
	jalr		$t1

	la	$a0 bool_const0
	# jumpt finish
	b	label355

# False:
label354:
	# Let expr
	# First eval init
	# Object:
	# It is self.
	move	$a0 $s0

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	la	$a0 int_const4
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# While loop
	# start:
label357:
	# ACC = pred
	# the 'not' operator
	# First eval the bool
	# equal
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is a param.
	lw	$a0 12($fp)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label359
	# Load false
	la	$a0 bool_const0
	# finish:
label359:
	# extract int inside bool
	lw	$t1 12($a0)

	# if pred == false jumpto finish
	beq	$t1 $zero label358

#== Assign. First eval the expr ==
	# Int operation : Add
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	add	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 4($sp)
#== Assign. First eval the expr ==
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label360
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label360:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto next
	jalr		$t1

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 8($sp)
	# Jumpto start
	b	label357
	# Finish:
label358:
	# ACC = void
	move	$a0 $zero
	# Let expr
	# First eval init
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label361
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label361:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto next
	jalr		$t1

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 20($sp)

	# if obj = void: abort
	bne	$a0 $zero label362
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label362:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto linkBehind
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label363
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label363:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto link
	jalr		$t1

	# pop
	addiu	$sp $sp 4

#== Assign. First eval the expr ==
	# Int operation : Add
	# First eval e1 and push.
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	add	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 20($s0)
	la	$a0 bool_const1
	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4

# Finish:
label355:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 8

	# return
	jr	$ra	

List.insertIdxN:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Dispatch. First eval and save the params.
	# the 'not' operator
	# First eval the bool
	# Int operation : Less or equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	ble	$t1 $t2 label364
	la	$a0 bool_const0
label364:
	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label365
	# Load false
	la	$a0 bool_const0
	# finish:
label365:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Int operation : Less than
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const4

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	blt	$t1 $t2 label366
	la	$a0 bool_const0
label366:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Op_protObj
	jal	Object.copy
	jal	Op_init
	# if obj = void: abort
	bne	$a0 $zero label367
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label367:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto or
	jalr		$t1

	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label368

	# Dispatch. First eval and save the params.
	la	$a0 str_const74
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label370
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label370:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto warning
	jalr		$t1

	la	$a0 bool_const0
	# jumpt finish
	b	label369

# False:
label368:
	# Let expr
	# First eval init
	# Object:
	# It is self.
	move	$a0 $s0

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	la	$a0 int_const4
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# While loop
	# start:
label371:
	# ACC = pred
	# the 'not' operator
	# First eval the bool
	# equal
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is a param.
	lw	$a0 12($fp)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label373
	# Load false
	la	$a0 bool_const0
	# finish:
label373:
	# extract int inside bool
	lw	$t1 12($a0)

	# if pred == false jumpto finish
	beq	$t1 $zero label372

#== Assign. First eval the expr ==
	# Int operation : Add
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	add	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 4($sp)
#== Assign. First eval the expr ==
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label374
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label374:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto next
	jalr		$t1

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 8($sp)
	# Jumpto start
	b	label371
	# Finish:
label372:
	# ACC = void
	move	$a0 $zero
	# Let expr
	# First eval init
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label375
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label375:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto next
	jalr		$t1

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 20($sp)

	# if obj = void: abort
	bne	$a0 $zero label376
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label376:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 44($t1)

	# jumpto linkBehindN
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label377
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label377:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto link
	jalr		$t1

	# pop
	addiu	$sp $sp 4

#== Assign. First eval the expr ==
	# Int operation : Add
	# First eval e1 and push.
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	add	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 20($s0)
	la	$a0 bool_const1
	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4

# Finish:
label369:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 8

	# return
	jr	$ra	

List.deleteIdx:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# the 'not' operator
	# First eval the bool
	# Int operation : Less or equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	ble	$t1 $t2 label378
	la	$a0 bool_const0
label378:
	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label379
	# Load false
	la	$a0 bool_const0
	# finish:
label379:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label380

	# Dispatch. First eval and save the params.
	la	$a0 str_const75
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label382
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label382:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto warning
	jalr		$t1

	la	$a0 bool_const0
	# jumpt finish
	b	label381

# False:
label380:
	# Let expr
	# First eval init
	# Object:
	# It is self.
	move	$a0 $s0

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	la	$a0 int_const4
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# While loop
	# start:
label383:
	# ACC = pred
	# the 'not' operator
	# First eval the bool
	# equal
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is a param.
	lw	$a0 12($fp)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label385
	# Load false
	la	$a0 bool_const0
	# finish:
label385:
	# extract int inside bool
	lw	$t1 12($a0)

	# if pred == false jumpto finish
	beq	$t1 $zero label384

#== Assign. First eval the expr ==
	# Int operation : Add
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	add	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 4($sp)
#== Assign. First eval the expr ==
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label386
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label386:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto next
	jalr		$t1

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 8($sp)
	# Jumpto start
	b	label383
	# Finish:
label384:
	# ACC = void
	move	$a0 $zero
#== Assign. First eval the expr ==
	# Int operation : Sub
	# First eval e1 and push.
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	sub	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 20($s0)
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label387
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label387:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 48($t1)

	# jumpto deleteBehind
	jalr		$t1

	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4

# Finish:
label381:
	la	$a0 bool_const1

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

List.insert:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	la	$a0 int_const4
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label388
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label388:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 60($t1)

	# jumpto insertIdx
	jalr		$t1


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

List.delete:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Let expr
	# First eval init
	# Object:
	# It is self.
	move	$a0 $s0

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	la	$a0 bool_const0
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# While loop
	# start:
label389:
	# ACC = pred
	# Dispatch. First eval and save the params.
	# the 'not' operator
	# First eval the bool
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label391
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label391:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto next
	jalr		$t1

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label392

	# acc != void
	la	$a0 bool_const0
# finish:
label392:
	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label393
	# Load false
	la	$a0 bool_const0
	# finish:
label393:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# the 'not' operator
	# First eval the bool
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label394
	# Load false
	la	$a0 bool_const0
	# finish:
label394:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Op_protObj
	jal	Object.copy
	jal	Op_init
	# if obj = void: abort
	bne	$a0 $zero label395
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label395:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto and
	jalr		$t1

	# extract int inside bool
	lw	$t1 12($a0)

	# if pred == false jumpto finish
	beq	$t1 $zero label390

	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label396
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label396:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto next
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label397
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label397:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto val
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is a param.
	lw	$a0 12($fp)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Pretend that t1 = t2
	la	$a0 bool_const1
	# Compare the two pointers.
	beq	$t1 $t2 label398
	la	$a0 bool_const0
label398:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label399

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label401
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label401:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto next
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label402
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label402:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto next
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 12($sp)

	# if obj = void: abort
	bne	$a0 $zero label403
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label403:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto link
	jalr		$t1

#== Assign. First eval the expr ==
	# Int operation : Sub
	# First eval e1 and push.
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	sub	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 20($s0)
#== Assign. First eval the expr ==
	la	$a0 bool_const1
#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 4($sp)
	# jumpt finish
	b	label400

# False:
label399:
#== Assign. First eval the expr ==
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label404
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label404:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto next
	jalr		$t1

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 8($sp)
# Finish:
label400:
	# Jumpto start
	b	label389
	# Finish:
label390:
	# ACC = void
	move	$a0 $zero
	# If statement. First eval condition.
	# the 'not' operator
	# First eval the bool
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label405
	# Load false
	la	$a0 bool_const0
	# finish:
label405:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label406

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	la	$a0 str_const77
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Mylib_protObj
	jal	Object.copy
	jal	Mylib_init
	# if obj = void: abort
	bne	$a0 $zero label408
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label408:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto item2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 str_const76
	# if obj = void: abort
	bne	$a0 $zero label409
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label409:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto concat
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label410
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label410:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto concat
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label411
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label411:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto warning
	jalr		$t1

	la	$a0 bool_const0
	# jumpt finish
	b	label407

# False:
label406:
	la	$a0 bool_const1
# Finish:
label407:
	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

List.search:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Let expr
	# First eval init
	# Object:
	# It is self.
	move	$a0 $s0

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	la	$a0 bool_const0
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# While loop
	# start:
label412:
	# ACC = pred
	# Dispatch. First eval and save the params.
	# the 'not' operator
	# First eval the bool
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label414
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label414:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto next
	jalr		$t1

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label415

	# acc != void
	la	$a0 bool_const0
# finish:
label415:
	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label416
	# Load false
	la	$a0 bool_const0
	# finish:
label416:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# the 'not' operator
	# First eval the bool
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label417
	# Load false
	la	$a0 bool_const0
	# finish:
label417:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Op_protObj
	jal	Object.copy
	jal	Op_init
	# if obj = void: abort
	bne	$a0 $zero label418
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label418:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto and
	jalr		$t1

	# extract int inside bool
	lw	$t1 12($a0)

	# if pred == false jumpto finish
	beq	$t1 $zero label413

	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label419
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label419:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto next
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label420
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label420:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto val
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is a param.
	lw	$a0 12($fp)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Pretend that t1 = t2
	la	$a0 bool_const1
	# Compare the two pointers.
	beq	$t1 $t2 label421
	la	$a0 bool_const0
label421:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label422

#== Assign. First eval the expr ==
	la	$a0 bool_const1
#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 4($sp)
	# jumpt finish
	b	label423

# False:
label422:
#== Assign. First eval the expr ==
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label424
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label424:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto next
	jalr		$t1

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 8($sp)
# Finish:
label423:
	# Jumpto start
	b	label412
	# Finish:
label413:
	# ACC = void
	move	$a0 $zero
	# If statement. First eval condition.
	# the 'not' operator
	# First eval the bool
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label425
	# Load false
	la	$a0 bool_const0
	# finish:
label425:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label426

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	la	$a0 str_const78
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Mylib_protObj
	jal	Object.copy
	jal	Mylib_init
	# if obj = void: abort
	bne	$a0 $zero label428
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label428:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto item2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 str_const76
	# if obj = void: abort
	bne	$a0 $zero label429
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label429:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto concat
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label430
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label430:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto concat
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label431
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label431:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto warning
	jalr		$t1

	la	$a0 bool_const0
	# jumpt finish
	b	label427

# False:
label426:
	la	$a0 bool_const1
# Finish:
label427:
	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

List.isEmpty:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# equal
	# First eval e1 and push.
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const4

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

List.length:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

List.valx:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Dispatch. First eval and save the params.
	# the 'not' operator
	# First eval the bool
	# Int operation : Less or equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	ble	$t1 $t2 label432
	la	$a0 bool_const0
label432:
	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label433
	# Load false
	la	$a0 bool_const0
	# finish:
label433:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Int operation : Less than
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const4

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	blt	$t1 $t2 label434
	la	$a0 bool_const0
label434:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Op_protObj
	jal	Object.copy
	jal	Op_init
	# if obj = void: abort
	bne	$a0 $zero label435
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label435:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto or
	jalr		$t1

	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label436

	# Dispatch. First eval and save the params.
	la	$a0 str_const79
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label438
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label438:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto warning
	jalr		$t1

	la	$a0 Object_protObj
	jal	Object.copy
	jal	Object_init
	# jumpt finish
	b	label437

# False:
label436:
	# Let expr
	# First eval init
	# Object:
	# It is self.
	move	$a0 $s0

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	la	$a0 int_const4
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# While loop
	# start:
label439:
	# ACC = pred
	# the 'not' operator
	# First eval the bool
	# equal
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is a param.
	lw	$a0 12($fp)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label441
	# Load false
	la	$a0 bool_const0
	# finish:
label441:
	# extract int inside bool
	lw	$t1 12($a0)

	# if pred == false jumpto finish
	beq	$t1 $zero label440

#== Assign. First eval the expr ==
	# Int operation : Add
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	add	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 4($sp)
#== Assign. First eval the expr ==
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label442
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label442:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto next
	jalr		$t1

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 8($sp)
	# Jumpto start
	b	label439
	# Finish:
label440:
	# ACC = void
	move	$a0 $zero
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label443
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label443:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto val
	jalr		$t1

	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4

# Finish:
label437:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

List.nodex:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Dispatch. First eval and save the params.
	# the 'not' operator
	# First eval the bool
	# Int operation : Less or equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Int operation : Sub
	# First eval e1 and push.
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	sub	$t3 $t1 $t2
	sw	$t3 12($a0)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	ble	$t1 $t2 label444
	la	$a0 bool_const0
label444:
	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label445
	# Load false
	la	$a0 bool_const0
	# finish:
label445:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Int operation : Less than
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Neg
	# Eval e1 and make a copy for result
	la	$a0 int_const3
	jal	Object.copy

	lw	$t1 12($a0)
	neg	$t1 $t1
	sw	$t1 12($a0)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	blt	$t1 $t2 label446
	la	$a0 bool_const0
label446:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Op_protObj
	jal	Object.copy
	jal	Op_init
	# if obj = void: abort
	bne	$a0 $zero label447
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label447:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto or
	jalr		$t1

	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label448

	# Dispatch. First eval and save the params.
	la	$a0 str_const80
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label450
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label450:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto warning
	jalr		$t1

	# Object:
	# It is self.
	move	$a0 $s0

	# jumpt finish
	b	label449

# False:
label448:
	# Let expr
	# First eval init
	# Object:
	# It is self.
	move	$a0 $s0

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	# Neg
	# Eval e1 and make a copy for result
	la	$a0 int_const3
	jal	Object.copy

	lw	$t1 12($a0)
	neg	$t1 $t1
	sw	$t1 12($a0)

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# While loop
	# start:
label451:
	# ACC = pred
	# the 'not' operator
	# First eval the bool
	# equal
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is a param.
	lw	$a0 12($fp)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label453
	# Load false
	la	$a0 bool_const0
	# finish:
label453:
	# extract int inside bool
	lw	$t1 12($a0)

	# if pred == false jumpto finish
	beq	$t1 $zero label452

#== Assign. First eval the expr ==
	# Int operation : Add
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	add	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 4($sp)
#== Assign. First eval the expr ==
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label454
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label454:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto next
	jalr		$t1

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 8($sp)
	# Jumpto start
	b	label451
	# Finish:
label452:
	# ACC = void
	move	$a0 $zero
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4

# Finish:
label449:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

List.print:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Dispatch. First eval and save the params.
	la	$a0 str_const81
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Object:
	# It is an attribute.
	lw	$a0 24($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 IO_protObj
	jal	Object.copy
	jal	IO_init
	# if obj = void: abort
	bne	$a0 $zero label455
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label455:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label456
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label456:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# Let expr
	# First eval init
	# Object:
	# It is self.
	move	$a0 $s0

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# While loop
	# start:
label457:
	# ACC = pred
	# the 'not' operator
	# First eval the bool
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# if obj = void: abort
	bne	$a0 $zero label459
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label459:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto next
	jalr		$t1

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label460

	# acc != void
	la	$a0 bool_const0
# finish:
label460:
	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label461
	# Load false
	la	$a0 bool_const0
	# finish:
label461:
	# extract int inside bool
	lw	$t1 12($a0)

	# if pred == false jumpto finish
	beq	$t1 $zero label458

#== Assign. First eval the expr ==
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# if obj = void: abort
	bne	$a0 $zero label462
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label462:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto next
	jalr		$t1

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 4($sp)
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# if obj = void: abort
	bne	$a0 $zero label463
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label463:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 52($t1)

	# jumpto print
	jalr		$t1

	# Jumpto start
	b	label457
	# Finish:
label458:
	# ACC = void
	move	$a0 $zero
	# Dispatch. First eval and save the params.
	la	$a0 str_const82
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 IO_protObj
	jal	Object.copy
	jal	IO_init
	# if obj = void: abort
	bne	$a0 $zero label464
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label464:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# pop
	addiu	$sp $sp 4


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

Stack.stack_init:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label465
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label465:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 56($t1)

	# jumpto list_init
	jalr		$t1

	# Object:
	# It is self.
	move	$a0 $s0


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Stack.push:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	la	$a0 int_const4
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label466
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label466:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 60($t1)

	# jumpto insertIdx
	jalr		$t1


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Stack.pop:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label467
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label467:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 84($t1)

	# jumpto isEmpty
	jalr		$t1

	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label468

	# Dispatch. First eval and save the params.
	la	$a0 str_const84
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label470
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label470:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto warning
	jalr		$t1

	# jumpt finish
	b	label469

# False:
label468:
	# Let expr
	# First eval init
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	la	$a0 int_const4
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label471
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label471:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 96($t1)

	# jumpto nodex
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label472
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label472:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto val
	jalr		$t1

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Dispatch. First eval and save the params.
	la	$a0 int_const4
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label473
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label473:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 68($t1)

	# jumpto deleteIdx
	jalr		$t1

	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# pop
	addiu	$sp $sp 4

# Finish:
label469:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

Stack.peek:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label474
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label474:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 84($t1)

	# jumpto isEmpty
	jalr		$t1

	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label475

	# Dispatch. First eval and save the params.
	la	$a0 str_const85
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label477
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label477:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto warning
	jalr		$t1

	# jumpt finish
	b	label476

# False:
label475:
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	la	$a0 int_const4
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label478
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label478:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 96($t1)

	# jumpto nodex
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label479
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label479:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto val
	jalr		$t1

# Finish:
label476:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

Queue.queue_init:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label480
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label480:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 56($t1)

	# jumpto list_init
	jalr		$t1

	# Object:
	# It is self.
	move	$a0 $s0


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Queue.enqueue:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label481
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label481:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 88($t1)

	# jumpto length
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label482
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label482:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 60($t1)

	# jumpto insertIdx
	jalr		$t1


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Queue.dequeue:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label483
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label483:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 84($t1)

	# jumpto isEmpty
	jalr		$t1

	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label484

	# Dispatch. First eval and save the params.
	la	$a0 str_const86
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label486
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label486:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto warning
	jalr		$t1

	# jumpt finish
	b	label485

# False:
label484:
	# Let expr
	# First eval init
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	la	$a0 int_const4
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label487
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label487:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 96($t1)

	# jumpto nodex
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label488
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label488:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto val
	jalr		$t1

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Dispatch. First eval and save the params.
	la	$a0 int_const4
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label489
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label489:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 68($t1)

	# jumpto deleteIdx
	jalr		$t1

	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# pop
	addiu	$sp $sp 4

# Finish:
label485:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

Queue.front:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label490
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label490:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 84($t1)

	# jumpto isEmpty
	jalr		$t1

	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label491

	# Dispatch. First eval and save the params.
	la	$a0 str_const87
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Throw_protObj
	jal	Object.copy
	jal	Throw_init
	# if obj = void: abort
	bne	$a0 $zero label493
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label493:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto warning
	jalr		$t1

	# jumpt finish
	b	label492

# False:
label491:
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	la	$a0 int_const4
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label494
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label494:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 96($t1)

	# jumpto nodex
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label495
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label495:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto val
	jalr		$t1

# Finish:
label492:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

BSTNode.bstnode_init:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label496
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label496:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto node_init
	jalr		$t1

	# Object:
	# It is self.
	move	$a0 $s0


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

BSTNode.left:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

BSTNode.right:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Object:
	# It is an attribute.
	lw	$a0 24($s0)


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

BSTNode.setLeft:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
#== Assign. First eval the expr ==
	# Object:
	# It is a param.
	lw	$a0 12($fp)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 20($s0)

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

BSTNode.setRight:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
#== Assign. First eval the expr ==
	# Object:
	# It is a param.
	lw	$a0 12($fp)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 24($s0)

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

BSTNode.value:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# case expr
	# First eval e0
	# Object:
	# It is an attribute.
	lw	$a0 16($s0)

	# If e0 = void, abort
	bne	$a0 $zero label497
	la	$a0 str_const0
	li	$t1 1
	jal	_case_abort2
label497:
	# T1 = type(acc)
	lw	$t1 0($a0)
	# tag = 2 : goto case 0
	li	$t2 2
	beq	$t1 $t2 label498

	# ----------------
	# No match
	jal	_case_abort
	b	label499
# eval expr 0
label498:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	addiu	$sp $sp 4
	# Jumpto finish
	b	label499
#finish:
label499:


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

BST.bst_init:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
#== Assign. First eval the expr ==
	# Object:
	# It is a param.
	lw	$a0 12($fp)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 16($s0)
	# Object:
	# It is self.
	move	$a0 $s0


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

BST.insert:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Let expr
	# First eval init
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 BSTNode_protObj
	jal	Object.copy
	jal	BSTNode_init
	# if obj = void: abort
	bne	$a0 $zero label500
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label500:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 56($t1)

	# jumpto bstnode_init
	jalr		$t1

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# If statement. First eval condition.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label501

	# acc != void
	la	$a0 bool_const0
# finish:
label501:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label502

#== Assign. First eval the expr ==
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 12($s0)
#== Assign. First eval the expr ==
	# Int operation : Add
	# First eval e1 and push.
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	add	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 20($s0)
	la	$a0 bool_const1
	# jumpt finish
	b	label503

# False:
label502:
	# Dispatch. First eval and save the params.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label504
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label504:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 20($t1)

	# jumpto insertHelper
	jalr		$t1

#== Assign. First eval the expr ==
	# Int operation : Add
	# First eval e1 and push.
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	add	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 20($s0)
	la	$a0 bool_const1
# Finish:
label503:
	# pop
	addiu	$sp $sp 4


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

BST.insertHelper:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Let expr
	# First eval init
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	# if obj = void: abort
	bne	$a0 $zero label505
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label505:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto val
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Mylib_protObj
	jal	Object.copy
	jal	Mylib_init
	# if obj = void: abort
	bne	$a0 $zero label506
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label506:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 40($t1)

	# jumpto item2i
	jalr		$t1

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label507
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label507:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto val
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Mylib_protObj
	jal	Object.copy
	jal	Mylib_init
	# if obj = void: abort
	bne	$a0 $zero label508
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label508:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 40($t1)

	# jumpto item2i
	jalr		$t1

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# If statement. First eval condition.
	# Int operation : Less than
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is a let variable.
	lw	$a0 12($sp)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	blt	$t1 $t2 label509
	la	$a0 bool_const0
label509:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label510

	# If statement. First eval condition.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	# if obj = void: abort
	bne	$a0 $zero label512
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label512:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 60($t1)

	# jumpto left
	jalr		$t1

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label513

	# acc != void
	la	$a0 bool_const0
# finish:
label513:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label514

	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	# if obj = void: abort
	bne	$a0 $zero label516
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label516:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 68($t1)

	# jumpto setLeft
	jalr		$t1

	# jumpt finish
	b	label515

# False:
label514:
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	# if obj = void: abort
	bne	$a0 $zero label517
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label517:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 60($t1)

	# jumpto left
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label518
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label518:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 20($t1)

	# jumpto insertHelper
	jalr		$t1

# Finish:
label515:
	# jumpt finish
	b	label511

# False:
label510:
	# If statement. First eval condition.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	# if obj = void: abort
	bne	$a0 $zero label519
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label519:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto right
	jalr		$t1

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label520

	# acc != void
	la	$a0 bool_const0
# finish:
label520:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label521

	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	# if obj = void: abort
	bne	$a0 $zero label523
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label523:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 72($t1)

	# jumpto setRight
	jalr		$t1

	# jumpt finish
	b	label522

# False:
label521:
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	# if obj = void: abort
	bne	$a0 $zero label524
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label524:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto right
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label525
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label525:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 20($t1)

	# jumpto insertHelper
	jalr		$t1

# Finish:
label522:
# Finish:
label511:
	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 8

	# return
	jr	$ra	

BST.search:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label526

	# acc != void
	la	$a0 bool_const0
# finish:
label526:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label527

	la	$a0 bool_const0
	# jumpt finish
	b	label528

# False:
label527:
	# Dispatch. First eval and save the params.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label529
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label529:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto searchHelper
	jalr		$t1

# Finish:
label528:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

BST.searchHelper:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label530

	# acc != void
	la	$a0 bool_const0
# finish:
label530:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label531

	la	$a0 bool_const0
	# jumpt finish
	b	label532

# False:
label531:
	# Let expr
	# First eval init
	# case expr
	# First eval e0
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	# if obj = void: abort
	bne	$a0 $zero label533
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label533:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto val
	jalr		$t1

	# If e0 = void, abort
	bne	$a0 $zero label534
	la	$a0 str_const0
	li	$t1 1
	jal	_case_abort2
label534:
	# T1 = type(acc)
	lw	$t1 0($a0)
	# tag = 2 : goto case 0
	li	$t2 2
	beq	$t1 $t2 label535

	# ----------------
	# No match
	jal	_case_abort
	b	label536
# eval expr 0
label535:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	addiu	$sp $sp 4
	# Jumpto finish
	b	label536
#finish:
label536:

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# If statement. First eval condition.
	# equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label537

	la	$a0 bool_const1
	# jumpt finish
	b	label538

# False:
label537:
	# If statement. First eval condition.
	# Int operation : Less than
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	blt	$t1 $t2 label539
	la	$a0 bool_const0
label539:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label540

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	# if obj = void: abort
	bne	$a0 $zero label542
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label542:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 60($t1)

	# jumpto left
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label543
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label543:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto searchHelper
	jalr		$t1

	# jumpt finish
	b	label541

# False:
label540:
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	# if obj = void: abort
	bne	$a0 $zero label544
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label544:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto right
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label545
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label545:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto searchHelper
	jalr		$t1

# Finish:
label541:
# Finish:
label538:
	# pop
	addiu	$sp $sp 4

# Finish:
label532:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 8

	# return
	jr	$ra	

BST.delete:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Let expr
	# First eval init
	la	$a0 bool_const0
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# If statement. First eval condition.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label546

	# acc != void
	la	$a0 bool_const0
# finish:
label546:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label547

	la	$a0 bool_const0
	# jumpt finish
	b	label548

# False:
label547:
#== Assign. First eval the expr ==
	# Dispatch. First eval and save the params.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 12($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label549
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label549:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto deleteHelper
	jalr		$t1

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 12($s0)
	# If statement. First eval condition.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label550

#== Assign. First eval the expr ==
	# Int operation : Sub
	# First eval e1 and push.
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	sub	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 20($s0)
	# jumpt finish
	b	label551

# False:
label550:
	la	$a0 int_const4
# Finish:
label551:
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

# Finish:
label548:
	# pop
	addiu	$sp $sp 4


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

BST.deleteHelper:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Object:
	# It is a param.
	lw	$a0 20($fp)

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label552

	# acc != void
	la	$a0 bool_const0
# finish:
label552:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label553

	# Object:
	# It is a param.
	lw	$a0 20($fp)

	# jumpt finish
	b	label554

# False:
label553:
	# Let expr
	# First eval init
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 20($fp)

	# if obj = void: abort
	bne	$a0 $zero label555
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label555:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto val
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Mylib_protObj
	jal	Object.copy
	jal	Mylib_init
	# if obj = void: abort
	bne	$a0 $zero label556
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label556:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 40($t1)

	# jumpto item2i
	jalr		$t1

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# If statement. First eval condition.
	# Int operation : Less than
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	blt	$t1 $t2 label557
	la	$a0 bool_const0
label557:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label558

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 20($fp)

	# if obj = void: abort
	bne	$a0 $zero label560
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label560:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 60($t1)

	# jumpto left
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label561
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label561:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto deleteHelper
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 20($fp)

	# if obj = void: abort
	bne	$a0 $zero label562
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label562:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 68($t1)

	# jumpto setLeft
	jalr		$t1

	# jumpt finish
	b	label559

# False:
label558:
	# If statement. First eval condition.
	# the 'not' operator
	# First eval the bool
	# Int operation : Less or equal
	# First eval e1 and push.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	ble	$t1 $t2 label563
	la	$a0 bool_const0
label563:
	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label564
	# Load false
	la	$a0 bool_const0
	# finish:
label564:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label565

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 20($fp)

	# if obj = void: abort
	bne	$a0 $zero label567
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label567:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto right
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label568
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label568:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto deleteHelper
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 20($fp)

	# if obj = void: abort
	bne	$a0 $zero label569
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label569:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 72($t1)

	# jumpto setRight
	jalr		$t1

	# jumpt finish
	b	label566

# False:
label565:
#== Assign. First eval the expr ==
	la	$a0 bool_const1
#== Now find the lvalue ==
#== It is a param ==
	sw	$a0 12($fp)
	# If statement. First eval condition.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 20($fp)

	# if obj = void: abort
	bne	$a0 $zero label570
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label570:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 60($t1)

	# jumpto left
	jalr		$t1

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label571

	# acc != void
	la	$a0 bool_const0
# finish:
label571:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 20($fp)

	# if obj = void: abort
	bne	$a0 $zero label572
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label572:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto right
	jalr		$t1

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label573

	# acc != void
	la	$a0 bool_const0
# finish:
label573:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Op_protObj
	jal	Object.copy
	jal	Op_init
	# if obj = void: abort
	bne	$a0 $zero label574
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label574:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto and
	jalr		$t1

	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label575

	# case expr
	# First eval e0
	# Dispatch. First eval and save the params.
	la	$a0 Object_protObj
	jal	Object.copy
	jal	Object_init
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 BSTNode_protObj
	jal	Object.copy
	jal	BSTNode_init
	# if obj = void: abort
	bne	$a0 $zero label577
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label577:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto node_init
	jalr		$t1

	# If e0 = void, abort
	bne	$a0 $zero label578
	la	$a0 str_const0
	li	$t1 1
	jal	_case_abort2
label578:
	# T1 = type(acc)
	lw	$t1 0($a0)
	# tag = 14 : goto case 0
	li	$t2 14
	beq	$t1 $t2 label579

	# ----------------
	# No match
	jal	_case_abort
	b	label580
# eval expr 0
label579:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	addiu	$sp $sp 4
	# Jumpto finish
	b	label580
#finish:
label580:

	# jumpt finish
	b	label576

# False:
label575:
	# If statement. First eval condition.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 20($fp)

	# if obj = void: abort
	bne	$a0 $zero label581
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label581:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto right
	jalr		$t1

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label582

	# acc != void
	la	$a0 bool_const0
# finish:
label582:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label583

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 20($fp)

	# if obj = void: abort
	bne	$a0 $zero label585
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label585:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 60($t1)

	# jumpto left
	jalr		$t1

	# jumpt finish
	b	label584

# False:
label583:
	# If statement. First eval condition.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 20($fp)

	# if obj = void: abort
	bne	$a0 $zero label586
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label586:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 60($t1)

	# jumpto left
	jalr		$t1

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label587

	# acc != void
	la	$a0 bool_const0
# finish:
label587:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label588

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 20($fp)

	# if obj = void: abort
	bne	$a0 $zero label590
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label590:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto right
	jalr		$t1

	# jumpt finish
	b	label589

# False:
label588:
	# Let expr
	# First eval init
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 20($fp)

	# if obj = void: abort
	bne	$a0 $zero label591
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label591:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto right
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label592
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label592:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 40($t1)

	# jumpto findMinVal
	jalr		$t1

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 20($fp)

	# if obj = void: abort
	bne	$a0 $zero label593
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label593:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 20($t1)

	# jumpto assign
	jalr		$t1

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 20($fp)

	# if obj = void: abort
	bne	$a0 $zero label594
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label594:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto right
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label595
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label595:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 44($t1)

	# jumpto deleteMin
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 20($fp)

	# if obj = void: abort
	bne	$a0 $zero label596
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label596:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 72($t1)

	# jumpto setRight
	jalr		$t1

	# Object:
	# It is a param.
	lw	$a0 20($fp)

	# pop
	addiu	$sp $sp 4

# Finish:
label589:
# Finish:
label584:
# Finish:
label576:
# Finish:
label566:
# Finish:
label559:
	# pop
	addiu	$sp $sp 4

# Finish:
label554:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 12

	# return
	jr	$ra	

BST.findMinVal:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label597
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label597:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 60($t1)

	# jumpto left
	jalr		$t1

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label598

	# acc != void
	la	$a0 bool_const0
# finish:
label598:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label599

	# case expr
	# First eval e0
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label601
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label601:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto val
	jalr		$t1

	# If e0 = void, abort
	bne	$a0 $zero label602
	la	$a0 str_const0
	li	$t1 1
	jal	_case_abort2
label602:
	# T1 = type(acc)
	lw	$t1 0($a0)
	# tag = 2 : goto case 0
	li	$t2 2
	beq	$t1 $t2 label603

	# ----------------
	# No match
	jal	_case_abort
	b	label604
# eval expr 0
label603:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	addiu	$sp $sp 4
	# Jumpto finish
	b	label604
#finish:
label604:

	# jumpt finish
	b	label600

# False:
label599:
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label605
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label605:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 60($t1)

	# jumpto left
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label606
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label606:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 40($t1)

	# jumpto findMinVal
	jalr		$t1

# Finish:
label600:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

BST.deleteMin:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label607
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label607:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 60($t1)

	# jumpto left
	jalr		$t1

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label608

	# acc != void
	la	$a0 bool_const0
# finish:
label608:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label609

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label611
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label611:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto right
	jalr		$t1

	# jumpt finish
	b	label610

# False:
label609:
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label612
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label612:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 60($t1)

	# jumpto left
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label613
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label613:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 44($t1)

	# jumpto deleteMin
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label614
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label614:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 68($t1)

	# jumpto setLeft
	jalr		$t1

	# Object:
	# It is a param.
	lw	$a0 12($fp)

# Finish:
label610:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

BST.printInOrder:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Dispatch. First eval and save the params.
	la	$a0 str_const81
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Object:
	# It is an attribute.
	lw	$a0 16($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 IO_protObj
	jal	Object.copy
	jal	IO_init
	# if obj = void: abort
	bne	$a0 $zero label615
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label615:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label616
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label616:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# If statement. First eval condition.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label617

	# acc != void
	la	$a0 bool_const0
# finish:
label617:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label618

	# Dispatch. First eval and save the params.
	la	$a0 str_const88
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 IO_protObj
	jal	Object.copy
	jal	IO_init
	# if obj = void: abort
	bne	$a0 $zero label620
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label620:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# jumpt finish
	b	label619

# False:
label618:
	# Dispatch. First eval and save the params.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label621
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label621:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 52($t1)

	# jumpto inOrder
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const49
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 IO_protObj
	jal	Object.copy
	jal	IO_init
	# if obj = void: abort
	bne	$a0 $zero label622
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label622:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

# Finish:
label619:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

BST.inOrder:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# If statement. First eval condition.
	# the 'not' operator
	# First eval the bool
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# t1 = acc
	move	$t1 $a0
	# First pretend t1 = void: acc = bool(1)
	la	$a0 bool_const1
	# if t1 = void: jumpto finish
	beq	$t1 $zero label623

	# acc != void
	la	$a0 bool_const0
# finish:
label623:
	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label624
	# Load false
	la	$a0 bool_const0
	# finish:
label624:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label625

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label627
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label627:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 60($t1)

	# jumpto left
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label628
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label628:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 52($t1)

	# jumpto inOrder
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const89
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# case expr
	# First eval e0
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label629
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label629:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto val
	jalr		$t1

	# If e0 = void, abort
	bne	$a0 $zero label630
	la	$a0 str_const0
	li	$t1 1
	jal	_case_abort2
label630:
	# T1 = type(acc)
	lw	$t1 0($a0)
	# tag = 2 : goto case 0
	li	$t2 2
	beq	$t1 $t2 label631

	# ----------------
	# No match
	jal	_case_abort
	b	label632
# eval expr 0
label631:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	addiu	$sp $sp 4
	# Jumpto finish
	b	label632
#finish:
label632:

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 A2I_protObj
	jal	Object.copy
	jal	A2I_init
	# if obj = void: abort
	bne	$a0 $zero label633
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label633:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto i2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 IO_protObj
	jal	Object.copy
	jal	IO_init
	# if obj = void: abort
	bne	$a0 $zero label634
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label634:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label635
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label635:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label636
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label636:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto right
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label637
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label637:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 52($t1)

	# jumpto inOrder
	jalr		$t1

	# jumpt finish
	b	label626

# False:
label625:
	la	$a0 int_const4
# Finish:
label626:

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

BST.size:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

BST.isEmpty:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# equal
	# First eval e1 and push.
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const4

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

Entry.init:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
#== Assign. First eval the expr ==
	# Object:
	# It is a param.
	lw	$a0 16($fp)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 12($s0)
#== Assign. First eval the expr ==
	# Object:
	# It is a param.
	lw	$a0 12($fp)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 16($s0)
	# Object:
	# It is self.
	move	$a0 $s0


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 8

	# return
	jr	$ra	

Entry.getKey:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

Entry.getValue:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Object:
	# It is an attribute.
	lw	$a0 16($s0)


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

Entry.setValue:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Let expr
	# First eval init
	# Object:
	# It is an attribute.
	lw	$a0 16($s0)

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

#== Assign. First eval the expr ==
	# Object:
	# It is a param.
	lw	$a0 12($fp)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 16($s0)
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# pop
	addiu	$sp $sp 4


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Entry.equalsKey:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# equal
	# First eval e1 and push.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is a param.
	lw	$a0 12($fp)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

Entry.print:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Dispatch. First eval and save the params.
	la	$a0 str_const92
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Object:
	# It is an attribute.
	lw	$a0 16($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	la	$a0 str_const91
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 A2I_protObj
	jal	Object.copy
	jal	A2I_init
	# if obj = void: abort
	bne	$a0 $zero label638
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label638:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto i2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	la	$a0 str_const90
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 IO_protObj
	jal	Object.copy
	jal	IO_init
	# if obj = void: abort
	bne	$a0 $zero label639
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label639:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label640
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label640:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label641
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label641:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label642
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label642:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label643
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label643:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

HashTable.ht_init:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
#== Assign. First eval the expr ==
	# Object:
	# It is a param.
	lw	$a0 16($fp)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 24($s0)
#== Assign. First eval the expr ==
	# Object:
	# It is a param.
	lw	$a0 12($fp)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 16($s0)
#== Assign. First eval the expr ==
	# Dispatch. First eval and save the params.
	la	$a0 str_const93
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 List_protObj
	jal	Object.copy
	jal	List_init
	# if obj = void: abort
	bne	$a0 $zero label644
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label644:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 56($t1)

	# jumpto list_init
	jalr		$t1

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 12($s0)
	# Let expr
	# First eval init
	la	$a0 int_const4
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# While loop
	# start:
label645:
	# ACC = pred
	# Int operation : Less than
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is an attribute.
	lw	$a0 16($s0)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	blt	$t1 $t2 label647
	la	$a0 bool_const0
label647:
	# extract int inside bool
	lw	$t1 12($a0)

	# if pred == false jumpto finish
	beq	$t1 $zero label646

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 A2I_protObj
	jal	Object.copy
	jal	A2I_init
	# if obj = void: abort
	bne	$a0 $zero label648
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label648:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto i2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 str_const94
	# if obj = void: abort
	bne	$a0 $zero label649
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label649:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto concat
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 List_protObj
	jal	Object.copy
	jal	List_init
	# if obj = void: abort
	bne	$a0 $zero label650
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label650:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 56($t1)

	# jumpto list_init
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Node_protObj
	jal	Object.copy
	jal	Node_init
	# if obj = void: abort
	bne	$a0 $zero label651
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label651:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto node_init
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label652
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label652:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 64($t1)

	# jumpto insertIdxN
	jalr		$t1

#== Assign. First eval the expr ==
	# Int operation : Add
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	add	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 4($sp)
	# Jumpto start
	b	label645
	# Finish:
label646:
	# ACC = void
	move	$a0 $zero
	# pop
	addiu	$sp $sp 4

	# Object:
	# It is self.
	move	$a0 $s0


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 8

	# return
	jr	$ra	

HashTable.hashFunc:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is an attribute.
	lw	$a0 16($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Op_protObj
	jal	Object.copy
	jal	Op_init
	# if obj = void: abort
	bne	$a0 $zero label653
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label653:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto mod
	jalr		$t1


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

HashTable.getBucket:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Let expr
	# First eval init
	# case expr
	# First eval e0
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is an attribute.
	lw	$a0 12($s0)

	# if obj = void: abort
	bne	$a0 $zero label654
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label654:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 96($t1)

	# jumpto nodex
	jalr		$t1

	# If e0 = void, abort
	bne	$a0 $zero label655
	la	$a0 str_const0
	li	$t1 1
	jal	_case_abort2
label655:
	# T1 = type(acc)
	lw	$t1 0($a0)
	# tag = 10 : goto case 0
	li	$t2 10
	beq	$t1 $t2 label656

	# ----------------
	# tag = 11 : goto case 0
	li	$t2 11
	beq	$t1 $t2 label656

	# tag = 14 : goto case 0
	li	$t2 14
	beq	$t1 $t2 label656

	# ----------------
	# tag = 12 : goto case 0
	li	$t2 12
	beq	$t1 $t2 label656

	# tag = 13 : goto case 0
	li	$t2 13
	beq	$t1 $t2 label656

	# ----------------
	# No match
	jal	_case_abort
	b	label657
# eval expr 0
label656:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	addiu	$sp $sp 4
	# Jumpto finish
	b	label657
#finish:
label657:

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# case expr
	# First eval e0
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# if obj = void: abort
	bne	$a0 $zero label658
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label658:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto val
	jalr		$t1

	# If e0 = void, abort
	bne	$a0 $zero label659
	la	$a0 str_const0
	li	$t1 1
	jal	_case_abort2
label659:
	# T1 = type(acc)
	lw	$t1 0($a0)
	# tag = 11 : goto case 0
	li	$t2 11
	beq	$t1 $t2 label660

	# ----------------
	# tag = 12 : goto case 0
	li	$t2 12
	beq	$t1 $t2 label660

	# tag = 13 : goto case 0
	li	$t2 13
	beq	$t1 $t2 label660

	# ----------------
	# No match
	jal	_case_abort
	b	label661
# eval expr 0
label660:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	addiu	$sp $sp 4
	# Jumpto finish
	b	label661
#finish:
label661:

	# pop
	addiu	$sp $sp 4


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

HashTable.put:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Let expr
	# First eval init
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label662
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label662:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto hashFunc
	jalr		$t1

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label663
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label663:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 20($t1)

	# jumpto getBucket
	jalr		$t1

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	la	$a0 int_const4
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	la	$a0 bool_const0
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	la	$a0 str_const18
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# While loop
	# start:
label664:
	# ACC = pred
	# Dispatch. First eval and save the params.
	# Int operation : Less than
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 12($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 20($sp)

	# if obj = void: abort
	bne	$a0 $zero label666
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label666:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 88($t1)

	# jumpto length
	jalr		$t1


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	blt	$t1 $t2 label667
	la	$a0 bool_const0
label667:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# the 'not' operator
	# First eval the bool
	# Object:
	# It is a let variable.
	lw	$a0 12($sp)

	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label668
	# Load false
	la	$a0 bool_const0
	# finish:
label668:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Op_protObj
	jal	Object.copy
	jal	Op_init
	# if obj = void: abort
	bne	$a0 $zero label669
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label669:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto and
	jalr		$t1

	# extract int inside bool
	lw	$t1 12($a0)

	# if pred == false jumpto finish
	beq	$t1 $zero label665

	# Let expr
	# First eval init
	# case expr
	# First eval e0
	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 12($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 20($sp)

	# if obj = void: abort
	bne	$a0 $zero label670
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label670:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 96($t1)

	# jumpto nodex
	jalr		$t1

	# If e0 = void, abort
	bne	$a0 $zero label671
	la	$a0 str_const0
	li	$t1 1
	jal	_case_abort2
label671:
	# T1 = type(acc)
	lw	$t1 0($a0)
	# tag = 10 : goto case 0
	li	$t2 10
	beq	$t1 $t2 label672

	# ----------------
	# tag = 11 : goto case 0
	li	$t2 11
	beq	$t1 $t2 label672

	# tag = 14 : goto case 0
	li	$t2 14
	beq	$t1 $t2 label672

	# ----------------
	# tag = 12 : goto case 0
	li	$t2 12
	beq	$t1 $t2 label672

	# tag = 13 : goto case 0
	li	$t2 13
	beq	$t1 $t2 label672

	# ----------------
	# No match
	jal	_case_abort
	b	label673
# eval expr 0
label672:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	addiu	$sp $sp 4
	# Jumpto finish
	b	label673
#finish:
label673:

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	# case expr
	# First eval e0
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# if obj = void: abort
	bne	$a0 $zero label674
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label674:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto val
	jalr		$t1

	# If e0 = void, abort
	bne	$a0 $zero label675
	la	$a0 str_const0
	li	$t1 1
	jal	_case_abort2
label675:
	# T1 = type(acc)
	lw	$t1 0($a0)
	# tag = 16 : goto case 0
	li	$t2 16
	beq	$t1 $t2 label676

	# ----------------
	# No match
	jal	_case_abort
	b	label677
# eval expr 0
label676:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	addiu	$sp $sp 4
	# Jumpto finish
	b	label677
#finish:
label677:

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# If statement. First eval condition.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label678
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label678:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto equalsKey
	jalr		$t1

	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label679

#== Assign. First eval the expr ==
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label681
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label681:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 24($t1)

	# jumpto setValue
	jalr		$t1

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 12($sp)
#== Assign. First eval the expr ==
	la	$a0 bool_const1
#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 16($sp)
	# jumpt finish
	b	label680

# False:
label679:
#== Assign. First eval the expr ==
	# Int operation : Add
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 20($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	add	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 20($sp)
# Finish:
label680:
	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4

	# Jumpto start
	b	label664
	# Finish:
label665:
	# ACC = void
	move	$a0 $zero
	# If statement. First eval condition.
	# the 'not' operator
	# First eval the bool
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# Extract the int inside the bool
	lw	$t1 12($a0)
	# Pretend ACC = false, then we need to construct true
	la	$a0 bool_const1
	# If ACC = false, jumpto finish
	beq	$t1 $zero label682
	# Load false
	la	$a0 bool_const0
	# finish:
label682:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label683

	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 16($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Entry_protObj
	jal	Object.copy
	jal	Entry_init
	# if obj = void: abort
	bne	$a0 $zero label685
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label685:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto init
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 20($sp)

	# if obj = void: abort
	bne	$a0 $zero label686
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label686:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 72($t1)

	# jumpto insert
	jalr		$t1

#== Assign. First eval the expr ==
	# Int operation : Add
	# First eval e1 and push.
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	add	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 20($s0)
#== Assign. First eval the expr ==
	la	$a0 str_const18
#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 4($sp)
	# jumpt finish
	b	label684

# False:
label683:
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

# Finish:
label684:
	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 8

	# return
	jr	$ra	

HashTable.get:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Let expr
	# First eval init
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label687
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label687:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto hashFunc
	jalr		$t1

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label688
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label688:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 20($t1)

	# jumpto getBucket
	jalr		$t1

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	la	$a0 int_const4
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	la	$a0 str_const95
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# While loop
	# start:
label689:
	# ACC = pred
	# Dispatch. First eval and save the params.
	# Int operation : Less than
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 16($sp)

	# if obj = void: abort
	bne	$a0 $zero label691
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label691:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 88($t1)

	# jumpto length
	jalr		$t1


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	blt	$t1 $t2 label692
	la	$a0 bool_const0
label692:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# equal
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 str_const95

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Op_protObj
	jal	Object.copy
	jal	Op_init
	# if obj = void: abort
	bne	$a0 $zero label693
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label693:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto and
	jalr		$t1

	# extract int inside bool
	lw	$t1 12($a0)

	# if pred == false jumpto finish
	beq	$t1 $zero label690

	# Let expr
	# First eval init
	# case expr
	# First eval e0
	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 16($sp)

	# if obj = void: abort
	bne	$a0 $zero label694
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label694:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 96($t1)

	# jumpto nodex
	jalr		$t1

	# If e0 = void, abort
	bne	$a0 $zero label695
	la	$a0 str_const0
	li	$t1 1
	jal	_case_abort2
label695:
	# T1 = type(acc)
	lw	$t1 0($a0)
	# tag = 10 : goto case 0
	li	$t2 10
	beq	$t1 $t2 label696

	# ----------------
	# tag = 11 : goto case 0
	li	$t2 11
	beq	$t1 $t2 label696

	# tag = 14 : goto case 0
	li	$t2 14
	beq	$t1 $t2 label696

	# ----------------
	# tag = 12 : goto case 0
	li	$t2 12
	beq	$t1 $t2 label696

	# tag = 13 : goto case 0
	li	$t2 13
	beq	$t1 $t2 label696

	# ----------------
	# No match
	jal	_case_abort
	b	label697
# eval expr 0
label696:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	addiu	$sp $sp 4
	# Jumpto finish
	b	label697
#finish:
label697:

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	# case expr
	# First eval e0
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# if obj = void: abort
	bne	$a0 $zero label698
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label698:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto val
	jalr		$t1

	# If e0 = void, abort
	bne	$a0 $zero label699
	la	$a0 str_const0
	li	$t1 1
	jal	_case_abort2
label699:
	# T1 = type(acc)
	lw	$t1 0($a0)
	# tag = 16 : goto case 0
	li	$t2 16
	beq	$t1 $t2 label700

	# ----------------
	# No match
	jal	_case_abort
	b	label701
# eval expr 0
label700:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	addiu	$sp $sp 4
	# Jumpto finish
	b	label701
#finish:
label701:

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# If statement. First eval condition.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label702
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label702:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto equalsKey
	jalr		$t1

	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label703

#== Assign. First eval the expr ==
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# if obj = void: abort
	bne	$a0 $zero label705
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label705:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 20($t1)

	# jumpto getValue
	jalr		$t1

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 12($sp)
	# jumpt finish
	b	label704

# False:
label703:
#== Assign. First eval the expr ==
	# Int operation : Add
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 16($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	add	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 16($sp)
# Finish:
label704:
	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4

	# Jumpto start
	b	label689
	# Finish:
label690:
	# ACC = void
	move	$a0 $zero
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

HashTable.remove:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Let expr
	# First eval init
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label706
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label706:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto hashFunc
	jalr		$t1

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label707
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label707:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 20($t1)

	# jumpto getBucket
	jalr		$t1

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	la	$a0 int_const4
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	la	$a0 str_const18
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# While loop
	# start:
label708:
	# ACC = pred
	# Dispatch. First eval and save the params.
	# Int operation : Less than
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 16($sp)

	# if obj = void: abort
	bne	$a0 $zero label710
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label710:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 88($t1)

	# jumpto length
	jalr		$t1


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	blt	$t1 $t2 label711
	la	$a0 bool_const0
label711:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# equal
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 str_const18

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 Op_protObj
	jal	Object.copy
	jal	Op_init
	# if obj = void: abort
	bne	$a0 $zero label712
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label712:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto and
	jalr		$t1

	# extract int inside bool
	lw	$t1 12($a0)

	# if pred == false jumpto finish
	beq	$t1 $zero label709

	# Let expr
	# First eval init
	# case expr
	# First eval e0
	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 16($sp)

	# if obj = void: abort
	bne	$a0 $zero label713
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label713:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 96($t1)

	# jumpto nodex
	jalr		$t1

	# If e0 = void, abort
	bne	$a0 $zero label714
	la	$a0 str_const0
	li	$t1 1
	jal	_case_abort2
label714:
	# T1 = type(acc)
	lw	$t1 0($a0)
	# tag = 10 : goto case 0
	li	$t2 10
	beq	$t1 $t2 label715

	# ----------------
	# tag = 11 : goto case 0
	li	$t2 11
	beq	$t1 $t2 label715

	# tag = 14 : goto case 0
	li	$t2 14
	beq	$t1 $t2 label715

	# ----------------
	# tag = 12 : goto case 0
	li	$t2 12
	beq	$t1 $t2 label715

	# tag = 13 : goto case 0
	li	$t2 13
	beq	$t1 $t2 label715

	# ----------------
	# No match
	jal	_case_abort
	b	label716
# eval expr 0
label715:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	addiu	$sp $sp 4
	# Jumpto finish
	b	label716
#finish:
label716:

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	# case expr
	# First eval e0
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# if obj = void: abort
	bne	$a0 $zero label717
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label717:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto val
	jalr		$t1

	# If e0 = void, abort
	bne	$a0 $zero label718
	la	$a0 str_const0
	li	$t1 1
	jal	_case_abort2
label718:
	# T1 = type(acc)
	lw	$t1 0($a0)
	# tag = 16 : goto case 0
	li	$t2 16
	beq	$t1 $t2 label719

	# ----------------
	# No match
	jal	_case_abort
	b	label720
# eval expr 0
label719:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	addiu	$sp $sp 4
	# Jumpto finish
	b	label720
#finish:
label720:

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# If statement. First eval condition.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label721
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label721:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto equalsKey
	jalr		$t1

	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label722

#== Assign. First eval the expr ==
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# if obj = void: abort
	bne	$a0 $zero label724
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label724:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 20($t1)

	# jumpto getValue
	jalr		$t1

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 12($sp)
	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 16($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 24($sp)

	# if obj = void: abort
	bne	$a0 $zero label725
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label725:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 68($t1)

	# jumpto deleteIdx
	jalr		$t1

#== Assign. First eval the expr ==
	# Int operation : Sub
	# First eval e1 and push.
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	sub	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is an attribute ==
	sw	$a0 20($s0)
	# jumpt finish
	b	label723

# False:
label722:
#== Assign. First eval the expr ==
	# Int operation : Add
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 16($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	add	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 16($sp)
# Finish:
label723:
	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4

	# Jumpto start
	b	label708
	# Finish:
label709:
	# ACC = void
	move	$a0 $zero
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

HashTable.printBucket:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Let expr
	# First eval init
	la	$a0 int_const4
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Dispatch. First eval and save the params.
	la	$a0 str_const96
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 IO_protObj
	jal	Object.copy
	jal	IO_init
	# if obj = void: abort
	bne	$a0 $zero label726
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label726:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# While loop
	# start:
label727:
	# ACC = pred
	# Int operation : Less than
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label729
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label729:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 88($t1)

	# jumpto length
	jalr		$t1


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	blt	$t1 $t2 label730
	la	$a0 bool_const0
label730:
	# extract int inside bool
	lw	$t1 12($a0)

	# if pred == false jumpto finish
	beq	$t1 $zero label728

	# Let expr
	# First eval init
	# case expr
	# First eval e0
	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label731
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label731:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 96($t1)

	# jumpto nodex
	jalr		$t1

	# If e0 = void, abort
	bne	$a0 $zero label732
	la	$a0 str_const0
	li	$t1 1
	jal	_case_abort2
label732:
	# T1 = type(acc)
	lw	$t1 0($a0)
	# tag = 10 : goto case 0
	li	$t2 10
	beq	$t1 $t2 label733

	# ----------------
	# tag = 11 : goto case 0
	li	$t2 11
	beq	$t1 $t2 label733

	# tag = 14 : goto case 0
	li	$t2 14
	beq	$t1 $t2 label733

	# ----------------
	# tag = 12 : goto case 0
	li	$t2 12
	beq	$t1 $t2 label733

	# tag = 13 : goto case 0
	li	$t2 13
	beq	$t1 $t2 label733

	# ----------------
	# No match
	jal	_case_abort
	b	label734
# eval expr 0
label733:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	addiu	$sp $sp 4
	# Jumpto finish
	b	label734
#finish:
label734:

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Let expr
	# First eval init
	# case expr
	# First eval e0
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# if obj = void: abort
	bne	$a0 $zero label735
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label735:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto val
	jalr		$t1

	# If e0 = void, abort
	bne	$a0 $zero label736
	la	$a0 str_const0
	li	$t1 1
	jal	_case_abort2
label736:
	# T1 = type(acc)
	lw	$t1 0($a0)
	# tag = 16 : goto case 0
	li	$t2 16
	beq	$t1 $t2 label737

	# ----------------
	# No match
	jal	_case_abort
	b	label738
# eval expr 0
label737:
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	addiu	$sp $sp 4
	# Jumpto finish
	b	label738
#finish:
label738:

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	# if obj = void: abort
	bne	$a0 $zero label739
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label739:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 32($t1)

	# jumpto print
	jalr		$t1

	# pop
	addiu	$sp $sp 4

	# pop
	addiu	$sp $sp 4

	# If statement. First eval condition.
	# Int operation : Less than
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Int operation : Sub
	# First eval e1 and push.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a param.
	lw	$a0 12($fp)

	# if obj = void: abort
	bne	$a0 $zero label740
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label740:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 88($t1)

	# jumpto length
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	sub	$t3 $t1 $t2
	sw	$t3 12($a0)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	blt	$t1 $t2 label741
	la	$a0 bool_const0
label741:
	# extract the bool content from acc to t1
	lw	$t1 12($a0)

	# if t1 == 0 goto false
	beq	$t1 $zero label742

	# Dispatch. First eval and save the params.
	la	$a0 str_const97
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 IO_protObj
	jal	Object.copy
	jal	IO_init
	# if obj = void: abort
	bne	$a0 $zero label744
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label744:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# jumpt finish
	b	label743

# False:
label742:
	la	$a0 int_const4
# Finish:
label743:
#== Assign. First eval the expr ==
	# Int operation : Add
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	add	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 4($sp)
	# Jumpto start
	b	label727
	# Finish:
label728:
	# ACC = void
	move	$a0 $zero
	# Dispatch. First eval and save the params.
	la	$a0 str_const98
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 IO_protObj
	jal	Object.copy
	jal	IO_init
	# if obj = void: abort
	bne	$a0 $zero label745
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label745:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# pop
	addiu	$sp $sp 4


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 4

	# return
	jr	$ra	

HashTable.print:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Dispatch. First eval and save the params.
	la	$a0 str_const101
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 A2I_protObj
	jal	Object.copy
	jal	A2I_init
	# if obj = void: abort
	bne	$a0 $zero label746
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label746:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto i2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	la	$a0 str_const100
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Object:
	# It is an attribute.
	lw	$a0 16($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 A2I_protObj
	jal	Object.copy
	jal	A2I_init
	# if obj = void: abort
	bne	$a0 $zero label747
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label747:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto i2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	la	$a0 str_const99
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Object:
	# It is an attribute.
	lw	$a0 24($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 IO_protObj
	jal	Object.copy
	jal	IO_init
	# if obj = void: abort
	bne	$a0 $zero label748
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label748:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label749
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label749:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label750
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label750:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label751
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label751:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label752
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label752:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label753
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label753:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# Let expr
	# First eval init
	la	$a0 int_const4
	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# While loop
	# start:
label754:
	# ACC = pred
	# Int operation : Less than
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	# Object:
	# It is an attribute.
	lw	$a0 16($s0)


	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Pretend that t1 < t2
	la	$a0 bool_const1
	# If t1 < t2 jumpto finish
	blt	$t1 $t2 label756
	la	$a0 bool_const0
label756:
	# extract int inside bool
	lw	$t1 12($a0)

	# if pred == false jumpto finish
	beq	$t1 $zero label755

	# Let expr
	# First eval init
	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label757
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label757:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 20($t1)

	# jumpto getBucket
	jalr		$t1

	# push
	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Dispatch. First eval and save the params.
	la	$a0 str_const103
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# eval the obj in dispatch.
	# Object:
	# It is a let variable.
	lw	$a0 8($sp)

	# if obj = void: abort
	bne	$a0 $zero label758
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label758:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 88($t1)

	# jumpto length
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 A2I_protObj
	jal	Object.copy
	jal	A2I_init
	# if obj = void: abort
	bne	$a0 $zero label759
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label759:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto i2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	la	$a0 str_const102
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 20($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 A2I_protObj
	jal	Object.copy
	jal	A2I_init
	# if obj = void: abort
	bne	$a0 $zero label760
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label760:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 28($t1)

	# jumpto i2a
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 str_const94
	# if obj = void: abort
	bne	$a0 $zero label761
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label761:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 16($t1)

	# jumpto concat
	jalr		$t1

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 IO_protObj
	jal	Object.copy
	jal	IO_init
	# if obj = void: abort
	bne	$a0 $zero label762
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label762:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label763
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label763:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label764
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label764:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# if obj = void: abort
	bne	$a0 $zero label765
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label765:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# Dispatch. First eval and save the params.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	# Object:
	# It is self.
	move	$a0 $s0

	# if obj = void: abort
	bne	$a0 $zero label766
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label766:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 36($t1)

	# jumpto printBucket
	jalr		$t1

	# Dispatch. First eval and save the params.
	la	$a0 str_const49
	sw	$a0 0($sp)
	addiu	$sp $sp -4
	# eval the obj in dispatch.
	la	$a0 IO_protObj
	jal	Object.copy
	jal	IO_init
	# if obj = void: abort
	bne	$a0 $zero label767
	la	$a0 str_const0
	li	$t1 1
	jal	_dispatch_abort
label767:
	# Now we locate the method in the dispatch table.
	# t1 = self.dispTab
	lw	$t1 8($a0)

	# t1 = dispTab[offset]
	lw	$t1 12($t1)

	# jumpto out_string
	jalr		$t1

	# pop
	addiu	$sp $sp 4

#== Assign. First eval the expr ==
	# Int operation : Add
	# First eval e1 and push.
	# Object:
	# It is a let variable.
	lw	$a0 4($sp)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2 and make a copy for result.
	la	$a0 int_const3
	jal	Object.copy

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	# Extract the int inside the object.
	lw	$t1 12($t1)
	lw	$t2 12($t2)

	# Modify the int inside t2.
	add	$t3 $t1 $t2
	sw	$t3 12($a0)

#== Now find the lvalue ==
#== It is a let variable ==
	sw	$a0 4($sp)
	# Jumpto start
	b	label754
	# Finish:
label755:
	# ACC = void
	move	$a0 $zero
	# pop
	addiu	$sp $sp 4


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

HashTable.getSize:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

HashTable.getCapacity:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# Object:
	# It is an attribute.
	lw	$a0 16($s0)


	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	

HashTable.isEmpty:
	# push fp, s0, ra
	addiu	$sp $sp -12
	sw	$fp 12($sp)
	sw	$s0 8($sp)
	sw	$ra 4($sp)

	# fp now points to the return addr in stack
	addiu	$fp $sp 4

	# SELF = a0
	move	$s0 $a0

	# evaluating expression and put it to ACC
	# equal
	# First eval e1 and push.
	# Object:
	# It is an attribute.
	lw	$a0 20($s0)

	sw	$a0 0($sp)
	addiu	$sp $sp -4

	# Then eval e2.
	la	$a0 int_const4

	# Let's pop e1 to t1, move e2 to t2
	addiu	$sp $sp 4
	lw	$t1 0($sp)
	move	$t2 $a0

	la	$a0 bool_const1
	la	$a1 bool_const0
	jal	equality_test

	# pop fp, s0, ra
	lw	$fp 12($sp)
	lw	$s0 8($sp)
	lw	$ra 4($sp)
	addiu	$sp $sp 12

	# Pop arguments
	addiu	$sp $sp 0

	# return
	jr	$ra	



#+++++ ending CgenClassTable::code +++++



# end of generated code
