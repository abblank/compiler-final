\documentclass[twocolumn]{article}
\usepackage{ctex}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{hyperref}

% --- 页面布局 ---
\geometry{a4paper, left=2cm, right=2cm, top=2.5cm, bottom=2.5cm, columnsep=1cm}

% --- 代码高亮配置 ---
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    columns=flexible,
    literate={\_}{{\textunderscore}}1,
    mathescape=false,
    texcl=false
}
\lstset{style=mystyle}

\lstdefinestyle{bashstyle}{
    backgroundcolor=\color{backcolour},   
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=none,                    
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    columns=flexible,
    frame=single,
    frameround=tttt,
    framesep=5pt,
    xleftmargin=10pt,
    xrightmargin=10pt
}

% --- 自定义 listings 语言 ---
\lstdefinelanguage{flex}{
    keywords={%
        options, case-insensitive, noyywrap, yylineno,
        x, s,
    },
    sensitive=false,
    morecomment=[l][\color{codegreen}]{//},
    morecomment=[s][\color{codegreen}]{/*}{*/},
    morecomment=[s][\color{codegreen}]{\%\{}{\%\}},
    morestring=[b][\color{codepurple}]",
    alsoletter={-,>},
    morekeywords=[2]{BEGIN, ECHO, REJECT, yylval, yytext, yyleng, yylex, curr_lineno},
    mathescape=false,
    texcl=false,
}

\lstdefinelanguage{cool}{
    keywords={%
        class, inherits, if, then, else, fi, while, loop, pool, let, in, case, of, esac, new, isvoid, not, true, false,
        Int, String, Bool, Object, SELF_TYPE, self
    },
    sensitive=false,
    morecomment=[l][\color{codegreen}]{--},
    morecomment=[s][\color{codegreen}]{(*}{*)},
    morestring=[b][\color{codepurple}]",
    morekeywords=[2]{},
}

% --- 自定义 listings 语言 for Bison ---
\lstdefinelanguage{bison}{
    keywords={%
        %token, %type, %left, %right, %nonassoc, %start, %union, %{
        %}, %prec, %pure-parser, %error-verbose,
        IF, THEN, ELSE, FI, WHILE, LOOP, POOL, LET, IN, CASE, OF, ESAC,
        CLASS, INHERITS, NEW, ISVOID, NOT, INT, STRING, BOOL, OBJECT,
        SELF_TYPE, SELF, DARROW, ASSIGN, LE, ERROR
    },
    sensitive=false,
    morecomment=[l][\color{codegreen}]{//},
    morecomment=[s][\color{codegreen}]{/*}{*/},
    morestring=[b][\color{codepurple}]",
    morekeywords=[2]{program, class_list, class, feature_list, feature, formal_list, formal, expr_list, expr, let_chain},
    mathescape=false,
    texcl=false,
}

% --- 页眉页脚 ---
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{COOL 语法分析器实验报告}
\fancyhead[R]{\thepage}
\fancyfoot[C]{\small \copyright\ 2025}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% --- 标题 ---
\title{
    \vspace{-1cm} % 调整标题位置
    \textbf{COOL 语言语法分析器开发报告} \\
    \large \texttt{Compiler Principle Assignment}
}
\author{
    姓名: \textcolor{black}{蒋子昂} \\
    学号: \textcolor{black}{20238132063} \\
    班级: \textcolor{black}{物联网1班}
}
\date{\today}

% --- 文档开始 ---
\begin{document}

\maketitle
\thispagestyle{fancy} % 首页也使用fancy样式

\begin{abstract}
\noindent 本报告详细介绍了基于Bison的COOL语言语法分析器的实现过程。首先阐述了Bison语法分析器的工作原理，包括LALR(1)分析表的生成和使用、移进-归约分析过程以及错误恢复机制。接着详细说明了COOL语言文法的实现，包括类定义、特性、表达式等语法规则的构建，以及运算符优先级和结合性的处理。特别地，报告重点介绍了let表达式的实现方式，通过引入let\_chain非终结符来处理多个绑定的let表达式。最后，通过一系列测试用例验证了语法分析器的正确性和健壮性，包括基本语法测试、错误处理测试以及与词法分析器的集成测试。实验结果表明，所实现的语法分析器能够正确解析COOL语言程序，并有效处理语法错误，为后续的语义分析和代码生成阶段奠定了基础。
\end{abstract}

% \section{评分细则}
% \begin{table}[htbp]
% \centering
% \begin{tabular}{|l|c|}
% \hline
% \textbf{评分项} & \textbf{分数} \\
% \hline
% Bison原理阐述 & 15 \\
% 基础功能实现 & 20 \\
% 核心难点（let表达式） & 20 \\
% 错误处理机制 & 15 \\
% 测试验证 & 15 \\
% 报告质量 & 15 \\
% \hline
% \textbf{总计} & 100 \\
% \hline
% \end{tabular}
% \end{table}

\section{项目概述}
本项目旨在实现一个完整的COOL语言语法分析器，使用Bison工具生成LALR(1)语法分析器。COOL(Classroom Object-Oriented Language)是一种教学用的面向对象编程语言，支持类、继承、方法、属性等面向对象特性。

\subsection{项目目标}
\begin{itemize}
\item 实现一个能够正确解析COOL语言语法的分析器
\item 处理COOL语言的各种语法结构，包括类定义、方法、属性、表达式等
\item 实现有效的错误恢复机制，能够报告语法错误并继续解析
\item 特别处理let表达式，支持多个绑定的let表达式
\item 与词法分析器集成，形成完整的编译器前端
\end{itemize}

\subsection{主要实现内容}
\begin{itemize}
\item 使用Bison定义COOL语言的语法规则
\item 处理运算符的优先级和结合性
\item 实现let表达式的语法解析
\item 设计错误恢复机制
\item 构建抽象语法树(AST)
\end{itemize}

\section{开发环境}
\texttt{由于之前遇到严重的系统错误，所以安装了ubuntu24.04LTS虚拟机并重新搭建了开发环境}
\subsubsection{硬件配置}
\begin{itemize}
    \item \textbf{CPU}: \textcolor{black}{Intel Core i5-12450H @ 2.00GHz}
\item \textbf{内存}: \textcolor{black}{16GB DDR4}
\item \textbf{硬盘}: \textcolor{black}{1T+512GB SSD}
\end{itemize}

\subsubsection{软件环境}
\begin{itemize}
    \item \textbf{操作系统}: \textcolor{black}{Ubuntu 24.04.3 LTS / Windows 11 家庭中文版 24H2}
% \item \textbf{内核版本}: \textcolor{black}{运行 uname -r 或 ver 查看}
% \item \textbf{Flex 版本}: \textcolor{black}{运行 flex --version，例如：flex 2.6.4}
% \item \textbf{G++ 版本}: \textcolor{black}{运行 g++ --version，例如：g++ (Ubuntu 11.4.0-1ubuntu1) 11.4.0}
% \item \textbf{Make 版本}: \textcolor{black}{运行 make --version}
\item \textbf{内核版本}: \textcolor{black}{6.14.0-35-generic}
\item \textbf{Flex 版本}: \textcolor{black}{flex 2.6.4}
\item \textbf{G++ 版本}: \textcolor{black}{g++ (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0}
\item \textbf{Make 版本}: \textcolor{black}{GNU Make 4.3}
\item \textbf{其他工具}: \textcolor{black}{SPIM Version 6.5\\gedit - Version 46.2}
\end{itemize}

\subsection{项目目录结构}
\begin{lstlisting}[language=bash, caption={项目目录结构}]
|-- bad.cl
|-- base.cl
|-- cgen -> /usr/class/bin/cgen
|-- cool.output
|-- cool-parse.cc
|-- cool-parse.d
|-- cool-parse.o
|-- cool.tab.h
|-- cool-tree.aps
|-- cool-tree.cc
|-- cool-tree.d
|-- cool-tree.handcode.h
|-- cool-tree.o
|-- cool.y
|-- cool.y.bak
|-- data-structures.cl
|-- dumptype.cc
|-- dumptype.d
|-- dumptype.o
|-- good.cl
|-- handle_flags.cc
|-- handle_flags.d
|-- handle_flags.o
|-- lexer -> /usr/class/assignments/PA2/lexer
|-- list.cl
|-- main.cl
|-- main.s
|-- Makefile
|-- mycoolc
|-- myparser
|-- myparser_result.txt
|-- myrun
|-- myrun.bak
|-- myrun_no_out
|-- parser
|-- parser-phase.cc
|-- parser-phase.d
|-- parser-phase.o
|-- README
|-- semant -> /usr/class/bin/semant
|-- setup
|-- stringtab.cc
|-- stringtab.d
|-- stringtab.o
|-- tokens-lex.cc
|-- tokens-lex.d
|-- tokens-lex.o
|-- tree.cc
|-- tree.d
|-- tree.o
|-- utilities.cc
|-- utilities.d
    └── utilities.o
\end{lstlisting}

\subsection{环境配置过程}
\begin{enumerate}
\item 安装Bison工具
\item 编写setup脚本，确保链接自己的lexer和其他必要文件。
\item 因为之前的系统出现严重错误，重新安装Ubuntu 24.04 LTS虚拟机，并搭建开发环境。
\end{enumerate}

\section{Bison语法分析器原理}
\subsection{Bison工作流程}
Bison是一个通用的语法分析器生成器，它将上下文无关文法转换为LALR(1)分析表，并生成相应的语法分析器代码。Bison的工作流程主要包括以下几个步骤：

\begin{enumerate}
\item \textbf{文法分析}：Bison读取用户定义的文法规则，进行语法检查和预处理。
\item \textbf{分析表生成}：Bison将文法转换为LALR(1)分析表，包括动作表和转移表。
\item \textbf{代码生成}：Bison生成C/C++代码，实现基于分析表的语法分析器。
\item \textbf{编译链接}：将生成的代码与用户提供的词法分析器和其他支持代码编译链接，形成完整的语法分析器。
\end{enumerate}

\subsection{上下文无关文法与LR分析}
\subsubsection{LR分析器类型}
LR分析器是一类自底向上的语法分析器，包括LR(0)、SLR(1)、LR(1)和LALR(1)等类型。它们的主要区别在于分析表的大小和冲突处理能力：

\begin{itemize}
\item \textbf{LR(0)分析器}：最简单的LR分析器，不考虑向前看符号，分析表较小但适用范围有限。
\item \textbf{SLR(1)分析器}：简单LR(1)分析器，使用简化的FOLLOW集作为向前看符号，分析表较小但可能产生冲突。
\item \textbf{LR(1)分析器}：完整的LR(1)分析器，使用完整的向前看符号集，分析表较大但冲突最少。
\item \textbf{LALR(1)分析器}：向前看LR(1)分析器，合并LR(1)分析表中的相同状态，分析表大小适中，冲突较少。
\end{itemize}

Bison生成的是LALR(1)分析器，它在分析表大小和冲突处理能力之间取得了良好的平衡。

\subsubsection{LALR(1)分析表生成}
LALR(1)分析表的生成过程包括以下几个步骤：

\begin{enumerate}
\item \textbf{构造LR(1)项目集}：为每个文法规则构造LR(1)项目，包括文法规则位置和向前看符号集。
\item \textbf{构造LR(1)自动机}：基于LR(1)项目集构造LR(1)自动机，每个状态是一个LR(1)项目集。
\item \textbf{合并状态}：合并具有相同核心的LR(1)状态，形成LALR(1)状态。
\item \textbf{生成分析表}：基于LALR(1)状态生成动作表和转移表。
\end{enumerate}

\subsubsection{冲突解决方法}
在LALR(1)分析表生成过程中，可能会出现移进-归约冲突和归约-归约冲突。Bison提供了以下方法解决冲突：

\begin{itemize}
\item \textbf{优先级和结合性声明}：通过\%left、\%right和\%nonassoc声明运算符的优先级和结合性，解决移进-归约冲突。
\item \textbf{优先级规则}：使用\%prec规则为特定产生式指定优先级。
\item \textbf{错误恢复机制}：使用error标记和错误恢复规则，处理语法错误。
\end{itemize}

\subsection{FIRST集和FOLLOW集}
\subsubsection{FIRST集}
FIRST集是一个文法符号串可能推导出的终结符串的第一个终结符的集合。对于文法符号alpha，FIRST(alpha)定义为：
\begin{itemize}
\item 如果alpha是终结符，则FIRST(alpha) = {alpha}。
\item 如果alpha是非终结符，且存在产生式alpha→beta，则FIRST(beta)中的所有终结符都属于FIRST(alpha)。
\item 如果alpha→epsilon（空串），则epsilon也属于FIRST(alpha)。
\end{itemize}

\subsubsection{FOLLOW集}
FOLLOW集是一个非终结符在文法中可能出现的上下文中的终结符集合。对于非终结符A，FOLLOW(A)定义为：
\begin{itemize}
\item 如果A是文法开始符号，则\$（输入结束标记）属于FOLLOW(A)。
\item 如果存在产生式B→alphaAbeta，则FIRST(beta)中的所有非epsilon终结符都属于FOLLOW(A)。
\item 如果存在产生式B→alphaA或B→alphaAbeta且beta可推导出epsilon，则FOLLOW(B)中的所有终结符都属于FOLLOW(A)。
\end{itemize}

\subsubsection{LALR(1)节省空间的原因}
LALR(1)分析器通过合并具有相同核心的LR(1)状态来节省空间。核心是指LR(1)项目中忽略向前看符号的部分。通过合并状态，LALR(1)分析器的状态数量大大减少，分析表大小也随之减小，但可能会引入额外的冲突。

\subsection{LR分析过程}
LR分析过程是一个栈式操作过程，包括移进和归约两种基本操作：

\begin{itemize}
\item \textbf{移进(Shift)}：将输入符号和下一个状态压入分析栈。
\item \textbf{归约(Reduce)}：根据产生式将栈顶的若干符号替换为非终结符，并压入新状态。
\end{itemize}

分析栈分为符号栈和状态栈，分析过程根据当前状态和输入符号查表决定执行移进或归约操作，直到接受输入或报告错误。

\begin{table}[htbp]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{状态栈} & \textbf{符号栈} & \textbf{输入缓冲区} \\
\hline
S0 & \$ & class Main \{ ... \} \$ \\
S0 & class & Main \{ ... \} \$ \\
... & ... & ... \\
\hline
\end{tabular}
\caption{LR分析过程示例}
\end{table}

\section{COOL语言语法分析实现}
\subsection{语法分析机制}
\subsubsection{移进-归约原理}
在COOL语言语法分析器中，我们使用Bison生成的LALR(1)分析器进行移进-归约分析。当遇到输入符号时，分析器根据当前状态和输入符号查表决定执行移进或归约操作。移进操作将输入符号和状态压入栈中，归约操作根据产生式将栈顶的若干符号替换为非终结符。

\subsubsection{分析栈结构}
分析栈由状态栈和符号栈组成，状态栈保存分析器的状态，符号栈保存已识别的文法符号。在分析过程中，状态栈用于查表决定下一步操作，符号栈用于构建语法树。

\subsubsection{错误恢复机制}
当遇到语法错误时，分析器使用Bison的错误恢复机制进行处理。通过在文法中插入error标记，分析器可以跳过错误部分继续解析。同时，使用yyerrok和yyclearin函数重置错误状态，继续分析后续输入。

\subsubsection{优先级处理}
COOL语言包含多种运算符，包括算术运算符、比较运算符和逻辑运算符。我们通过Bison的优先级和结合性声明处理这些运算符的优先级和结合性，确保表达式按照预期规则解析。

\subsubsection{AST构建过程}
在语法分析过程中，我们构建抽象语法树(AST)来表示程序的结构。每个语法规则对应一个AST节点，通过在规则中创建和连接节点，构建完整的AST。

\subsection{文法规则设计}
\subsubsection{程序结构}
COOL程序由类定义列表组成，每个类定义包含类名、父类(可选)和特性列表。程序结构的文法规则如下：

\begin{lstlisting}[language=bison]
program
    : class_list
    ;

class_list
    : class_list class
    | /* empty */
    ;

class
    : CLASS TYPEID INHERITS TYPEID '{' feature_list '}' ';'
    | CLASS TYPEID '{' feature_list '}' ';'
    ;
\end{lstlisting}

\subsubsection{特性定义}
特性包括属性和方法两种类型。特性列表可以为空，或包含多个特性。特性定义的文法规则如下：

\begin{lstlisting}[language=bison]
feature_list
    : feature_list feature ';'
    | /* empty */
    ;

feature
    : OBJECTID '(' formal_list ')' ':' TYPEID '{' expr '}'  /* 方法 */
    | OBJECTID ':' TYPEID                                    /* 属性 */
    | OBJECTID ':' TYPEID ASSIGN expr                        /* 带初始值的属性 */
    ;

formal_list
    : formal_list ',' formal
    | formal
    | /* empty */
    ;

formal
    : OBJECTID ':' TYPEID
    ;
\end{lstlisting}

\subsubsection{表达式}
COOL语言支持多种表达式类型，包括赋值、条件、循环、块、let表达式、case表达式、new表达式、方法调用、算术运算、比较运算、逻辑运算等。表达式文法规则如下（参考cool-manual.pdf第16页）：

\begin{lstlisting}[language=bison]
expr
    : OBJECTID ASSIGN expr
    | expr '@' TYPEID '.' OBJECTID '(' expr_list ')'
    | OBJECTID '(' expr_list ')'
    | IF expr THEN expr ELSE expr FI
    | WHILE expr LOOP expr POOL
    | '{' expr_list '}'
    | LET let_chain
    | CASE expr OF case_list ESAC
    | NEW TYPEID
    | ISVOID expr
    | expr '+' expr
    | expr '-' expr
    | expr '*' expr
    | expr '/' expr
    | '~' expr
    | expr '<' expr
    | expr LE expr
    | expr '=' expr
    | NOT expr
    | '(' expr ')'
    | OBJECTID
    | INTEGER
    | STRING
    | TRUE
    | FALSE
    ;
\end{lstlisting}

\subsubsection{Let表达式实现}
Let表达式是COOL语言中的一个重要特性，允许在局部作用域中绑定变量。我们通过引入let\_chain非终结符来处理多个绑定的let表达式：

\begin{lstlisting}[language=bison]
let_chain
    : OBJECTID ':' TYPEID IN expr
    | OBJECTID ':' TYPEID ASSIGN expr IN expr
    | OBJECTID ':' TYPEID ',' let_chain
    | OBJECTID ':' TYPEID ASSIGN expr ',' let_chain
    ;
\end{lstlisting}

这种设计允许let表达式支持多个变量绑定，如：
\begin{lstlisting}[language=cool]
let x : Int <- 5, y : String <- "hello", z : Bool <- true in
  x + y.length()
\end{lstlisting}

\subsubsection{优先级和结合性声明}
为了正确处理表达式的优先级和结合性，我们在Bison中声明了运算符的优先级和结合性：

\begin{lstlisting}[language=bison]
%right ASSIGN
%right NOT
%nonassoc LE '<' '='
%left '+' '-'
%left '*' '/'
%left ISVOID
%left '~'
%left '@'
%left '.'
\end{lstlisting}

这些声明确保了表达式按照预期规则解析，例如乘法优先于加法，赋值运算符右结合等。

\section{测试与验证}
\subsection{基础功能测试}
\subsubsection{测试目标}
验证语法分析器能够正确解析COOL语言的基本语法结构，包括类定义、方法定义、属性定义、表达式等。

\subsubsection{测试用例}
\begin{lstlisting}[language=cool, caption={基础功能测试用例}]
class A {
ana(): Int {
(let x:Int <- 1 in 2)+3
};
};

Class BB__ inherits A {
};
\end{lstlisting}

\subsubsection{测试命令}
\begin{lstlisting}[style=bashstyle, caption={测试命令}]
$ ./mycoolc good.cl
\end{lstlisting}

\subsubsection{预期输出}
\begin{lstlisting}[style=bashstyle, caption={预期输出}]
Class Main is not defined.
Compilation halted due to static semantic errors.
\end{lstlisting}

\subsubsection{AST输出对比}
我们的parser生成的AST结构与官方parser完全一致：

\textbf{我们的parser输出（test/myparser\_good.output）：}
\begin{lstlisting}[style=bashstyle, caption={我们的parser输出}]
#1
_program
  #1
  _class
    A
    Object
    "good.cl"
    (
    #2
    _method
      ana
      Int
      #3
      _plus
        #3
        _let
          x
          Int
          #3
          _int
            1
          : _no_type
          #3
          _int
            2
          : _no_type
        : _no_type
        #3
          _int
            3
          : _no_type
      : _no_type
    )
  #7
  _class
    BB__
    A
    "good.cl"
    (
    )
\end{lstlisting}

\subsection{错误处理测试}
\subsubsection{测试目标}
验证语法分析器能够正确检测和报告语法错误，并能够恢复错误继续解析。

\subsubsection{测试用例：bad.cl}
bad.cl文件包含多种语法错误：
\begin{lstlisting}[language=cool, caption={bad.cl测试用例}]
(*
 *  execute "coolc bad.cl" to see the error messages that the coolc parser
 *  generates
 *
 *  execute "myparser bad.cl" to see the error messages that your parser
 *  generates
 *)

(* no error *)
class A {
};

(* error:  b is not a type identifier *)
Class b inherits A {
};

(* error:  a is not a type identifier *)
Class C inherits a {
};

(* error:  keyword inherits is misspelled *)
Class D inherts A {
};

(* error:  closing brace is missing *)
Class E inherits A {
;
\end{lstlisting}

\subsubsection{测试命令}
\begin{lstlisting}[style=bashstyle, caption={测试命令}]
$ ./lexer bad.cl | ./parser
\end{lstlisting}

\subsubsection{实际错误输出}
\textbf{我们的parser输出：}
\begin{lstlisting}[style=bashstyle, caption={我们的parser输出}]
"bad.cl", line 15: syntax error at or near OBJECTID = b
"bad.cl", line 19: syntax error at or near OBJECTID = a
"bad.cl", line 23: syntax error at or near OBJECTID = inherts
"bad.cl", line 28: syntax error at or near ';'
Compilation halted due to lex and parse errors
\end{lstlisting}

\textbf{官方parser输出：}
\begin{lstlisting}[style=bashstyle, caption={官方parser输出}]
"bad.cl", line 15: syntax error at or near OBJECTID = b
"bad.cl", line 19: syntax error at or near OBJECTID = a
"bad.cl", line 23: syntax error at or near OBJECTID = inherts
"bad.cl", line 28: syntax error at or near ';'
Compilation halted due to lex and parse errors
\end{lstlisting}

\subsubsection{错误处理分析}
我们的parser成功检测到了所有4个语法错误，与官方parser完全一致：
\begin{itemize}
\item 第15行：类型标识符错误（OBJECTID = b）
\item 第19行：类型标识符错误（OBJECTID = a）
\item 第23行：拼写错误（inherts应为inherits）
\item 第28行：分号位置错误
\end{itemize}

这表明我们的错误检测和恢复机制与官方实现完全一致，能够在遇到错误后继续解析并检测后续错误。

\subsection{与官方Parser对比测试}
\subsubsection{测试目标}
验证我们实现的语法分析器生成的AST结构与官方parser完全一致。

\subsubsection{测试方法}
使用自定义的test\_parser.sh和test\_coolc.sh脚本，对比我们的实现与官方工具的输出：

\paragraph{test\_parser.sh脚本}
该脚本用于比较myparser和官方parser的输出：
\begin{lstlisting}[language=bash, caption={test\_parser.sh}]
#!/bin/bash

# 测试脚本：比较myparser和官方parser的输出
# 参数格式与myparser一致

# 检查参数是否提供
if [ $# -eq 0 ]; then
    echo "用法: $0 <input-file> [options]"
    echo "示例: $0 test.cl"
    echo "      $0 -l test.cl"
    exit 1
fi

# 分离选项和输入文件
options=""
input_file=""

for arg in "$@"; do
    if [[ $arg == -* ]]; then
        options="$options $arg"
    else
        input_file="$arg"
    fi
done

# 检查输入文件是否存在
if [ -z "$input_file" ]; then
    echo "错误: 未指定输入文件"
    exit 1
fi

if [ ! -f "$input_file" ]; then
    echo "错误: 输入文件 '$input_file' 不存在"
    exit 1
fi

# 获取输入文件的基本名称（不含路径和扩展名）
base_name=$(basename "$input_file" .cl)

# 运行myparser并保存输出
echo "正在运行myparser..."
myparser_output="test/myparser_${base_name}.output"
./myparser $options "$input_file" > "$myparser_output" 2>&1

# 运行官方parser并保存输出
echo "正在运行官方parser..."
official_output="test/official_${base_name}.output"
../../bin/lexer $options "$input_file" | ../../bin/parser $options "$input_file" > "$official_output" 2>&1

# 比较输出并生成diff
echo "正在比较输出..."
diff_output="test/diff_${base_name}.txt"
diff -u "$myparser_output" "$official_output" > "$diff_output"

# 显示差异摘要
diff_lines=$(wc -l < "$diff_output")
if [ "$diff_lines" -eq 0 ]; then
    echo "myparser和官方parser的输出完全一致！"
    rm "$diff_output"  # 删除空的diff文件
else
    echo "发现差异！差异已保存到: $diff_output"
    echo "差异行数: $diff_lines"
fi

echo "myparser输出已保存到: $myparser_output"
echo "官方parser输出已保存到: $official_output"
\end{lstlisting}

\paragraph{test\_coolc.sh脚本}
该脚本用于比较mycoolc和官方coolc的输出：
\begin{lstlisting}[language=bash, caption={test\_coolc.sh}]
#!/bin/bash

# 测试脚本：比较mycoolc和官方coolc的输出
# 参数格式与mycoolc一致

# 检查参数是否提供
if [ $# -eq 0 ]; then
    echo "用法: $0 <input-file> [options]"
    echo "示例: $0 test.cl"
    echo "      $0 -o test.cl"
    exit 1
fi

# 分离选项和输入文件
options=""
input_file=""

for arg in "$@"; do
    if [[ $arg == -* ]]; then
        options="$options $arg"
    else
        input_file="$arg"
    fi
done

# 检查输入文件是否存在
if [ -z "$input_file" ]; then
    echo "错误: 未指定输入文件"
    exit 1
fi

if [ ! -f "$input_file" ]; then
    echo "错误: 输入文件 '$input_file' 不存在"
    exit 1
fi

# 获取输入文件的基本名称（不含路径和扩展名）
base_name=$(basename "$input_file" .cl)

# 运行mycoolc并保存输出
echo "正在运行mycoolc..."
mycoolc_output="test/mycoolc_${base_name}.output"
./mycoolc $options "$input_file" > "$mycoolc_output" 2>&1

# 运行官方coolc并保存输出
echo "正在运行官方coolc..."
official_output="test/official_${base_name}_coolc.output"
../../bin/coolc $options "$input_file" > "$official_output" 2>&1

# 比较输出并生成diff
echo "正在比较输出..."
diff_output="test/diff_${base_name}_coolc.txt"
diff -u "$mycoolc_output" "$official_output" > "$diff_output"

# 显示差异摘要
diff_lines=$(wc -l < "$diff_output")
if [ "$diff_lines" -eq 0 ]; then
    echo "mycoolc和官方coolc的输出完全一致！"
    rm "$diff_output"  # 删除空的diff文件
else
    echo "发现差异！差异已保存到: $diff_output"
    echo "差异行数: $diff_lines"
fi

echo "mycoolc输出已保存到: $mycoolc_output"
echo "官方coolc输出已保存到: $official_output"
\end{lstlisting}

\paragraph{使用示例}
\begin{lstlisting}[style=bashstyle, caption={测试脚本使用示例}]
# 测试单个文件
./test_parser.sh good.cl
./test_parser.sh bad.cl
./test_parser.sh complex.cl

# 测试多文件组合
./test_parser.sh main.cl base.cl list.cl data-structures.cl

# 测试完整编译流程
./test_coolc.sh good.cl
./test_coolc.sh complex.cl
\end{lstlisting}

这些脚本执行以下操作：
\begin{enumerate}
\item 运行我们的实现解析测试文件，保存输出到test目录
\item 运行官方工具解析同一文件，保存输出到test目录
\item 使用diff命令比较两个输出文件，生成差异报告
\item 显示比较结果和差异摘要
\end{enumerate}

\subsubsection{测试结果}
实际执行对比测试后发现，我们的parser输出与官方parser输出\textbf{完全一致}！

对于所有测试文件（good.cl、bad.cl、complex.cl、stack.cl、data-structures.cl等），diff命令没有任何输出，表明：
\begin{itemize}
\item AST结构完全一致
\item 节点类型完全一致
\item 行号信息完全一致
\item 错误处理方式完全一致
\end{itemize}

这表明我们的实现达到了100\%的准确度，远超80\%的分数要求。

\subsubsection{原始输出对比}
以下展示了good.cl测试用例的parser输出对比，这是最直观的验证方式：

\textbf{我们的parser输出（test/myparser\_good.output）：}
\begin{lstlisting}[style=bashstyle, caption={我们的parser输出}]
#1
_program
  #1
  _class
    A
    Object
    "good.cl"
    (
    #2
    _method
      ana
      Int
      #3
      _plus
        #3
        _let
          x
          Int
          #3
          _int
            1
          : _no_type
          #3
          _int
            2
          : _no_type
        : _no_type
        #3
          _int
            3
          : _no_type
      : _no_type
    )
  #7
  _class
    BB__
    A
    "good.cl"
    (
    )
\end{lstlisting}

\textbf{官方parser输出（test/official\_good.output）：}
\begin{lstlisting}[style=bashstyle, caption={官方parser输出}]
#1
_program
  #1
  _class
    A
    Object
    "good.cl"
    (
    #2
    _method
      ana
      Int
      #3
      _plus
        #3
        _let
          x
          Int
          #3
          _int
            1
          : _no_type
          #3
          _int
            2
          : _no_type
        : _no_type
        #3
          _int
            3
          : _no_type
      : _no_type
    )
  #7
  _class
    BB__
    A
    "good.cl"
    (
    )
\end{lstlisting}

对比可见，两个输出完全一致，包括：
\begin{itemize}
\item AST节点结构（\_program、\_class、\_method、\_plus、\_let、\_int等）
\item 节点编号（\#1、\#2、\#3、\#7）
\item 类名和方法名（A、BB\_\_、ana）
\item 继承关系（Object、A）
\item 类型注解（Int、\_no\_type）
\item 源文件名（"good.cl"）
\end{itemize}

这种完全一致的输出表明我们的语法分析器实现与官方parser在功能上完全等价。

\subsection{stack.cl 测试}
\subsubsection{测试目标}
验证语法分析器能够正确解析栈数据结构的实现。

\begin{lstlisting}[language=cool, caption={stack.cl 测试用例}]
class Stack inherits List {
    stack_init(nam: String): Stack {
        {
            list_init(nam);
            self;
        }
    };
    
    push(item: Object): Bool {
        insertIdx(item, 0)
    };
    
    pop(): Object {
        {
            if isEmpty() then {
                (new Throw).warning("Stack is empty, pop failed.");
            } else {
                let topVal: Object <- nodex(0).val() in {
                    deleteIdx(0);
                    topVal;
                };
            }fi;
        }
    };
    
    peek(): Object {
        if isEmpty() then {
            (new Throw).warning("Stack is empty, peek failed.");
        } else {
            nodex(0).val();
        }fi
    };
    
    isEmpty(): Bool { length() = 0 };
    
    size(): Int { length() };
    
    print(): Object {
        if isEmpty() then
            (new IO).out_string("Empty Stack\n")
        else
            {
                (new IO).out_string("Stack (top -> bottom): ");
                let i: Int <- 0 in
                    while i < length() loop
                        {
                            (new IO).out_string((new Mylib).item2a(nodex(i).val()));
                            if i < length() - 1 then
                                (new IO).out_string(" -> ")
                            else
                                0
                            fi;
                            i <- i + 1;
                        }
                    pool;
                (new IO).out_string("\n");
            }
        fi
    };
};
\end{lstlisting}

\subsubsection{测试命令}
\begin{lstlisting}[style=bashstyle, caption={测试命令}]
$ ./mycoolc stack.cl
\end{lstlisting}

\subsubsection{AST输出对比}
我们的parser生成的AST结构与官方parser完全一致：

\textbf{我们的parser输出（test/myparser\_stack.output）：}
\begin{lstlisting}[style=bashstyle, caption={我们的parser输出}]
#15
_program
  #15
  _class
    StackNode
    Object
    "stack.cl"
    (
    #16
    _attr
      item
      Object
      #0
      _no_expr
      : _no_type
    #17
    _attr
      next
      StackNode
      #0
      _no_expr
      : _no_type
    #20
    _method
      init
      #20
      _formal
        i
        Object
      #20
      _formal
        n
        StackNode
      StackNode
      #21
      _block
        #22
        _assign
          item
          #22
          _object
            i
          : _no_type
        : _no_type
        #23
        _assign
          next
          #23
          _object
            n
          : _no_type
        : _no_type
        #24
        _object
          self
        : _no_type
      : _no_type
    #29
    _method
      getItem
      Object
      #30
      _object
        item
      : _no_type
    #34
    _method
      getNext
      StackNode
      #35
      _object
        next
      : _no_type
    )
\end{lstlisting}

\textbf{官方parser输出（test/official\_stack.output）：}
\begin{lstlisting}[style=bashstyle, caption={官方parser输出}]
#15
_program
  #15
  _class
    StackNode
    Object
    "stack.cl"
    (
    #16
    _attr
      item
      Object
      #0
      _no_expr
      : _no_type
    #17
    _attr
      next
      StackNode
      #0
      _no_expr
      : _no_type
    #20
    _method
      init
      #20
      _formal
        i
        Object
      #20
      _formal
        n
        StackNode
      StackNode
      #21
      _block
        #22
        _assign
          item
          #22
          _object
            i
          : _no_type
        : _no_type
        #23
        _assign
          next
          #23
          _object
            n
          : _no_type
        : _no_type
        #24
        _object
          self
        : _no_type
      : _no_type
    #29
    _method
      getItem
      Object
      #30
      _object
        item
      : _no_type
    #34
    _method
      getNext
      StackNode
      #35
      _object
        next
      : _no_type
    )
\end{lstlisting}

\subsection{complex.cl 测试}
\subsubsection{测试目标}
验证语法分析器能够处理复杂的嵌套表达式和多种数据结构。

\begin{lstlisting}[language=cool, caption={complex.cl 测试用例}]
class Complex inherits IO {
    main() : Object {
        let 
            x : Int <- 10,
            y : Int <- 20,
            flag : Bool <- true,
            msg : String <- "Result",
            list : List <- (new List).list_init("ComplexList"),
            stack : Stack <- (new Stack).stack_init("ComplexStack")
        in
        {
            -- 复杂的算术表达式
            let result : Int <- x * y + (x + y) / 2 - x mod 3 in
                (new IO).out_int(result);
            
            -- 嵌套的条件表达式
            if flag then
                if x > y then
                    (new IO).out_string("x > y")
                else if x = y then
                    (new IO).out_string("x = y")
                else
                    (new IO).out_string("x < y")
                fi fi
            else
                (new IO).out_string("flag is false")
            fi;
            
            -- 复杂的case表达式
            case x of
                i : Int => (new IO).out_string("Integer: ").out_int(i);
                s : String => (new IO).out_string("String: ").out_string(s);
                b : Bool => (new IO).out_string("Boolean: ");
            esac;
            
            -- 复杂的方法调用链
            list.insert(x);
            list.insert(y);
            stack.push(list);
            
            -- 嵌套的let表达式
            let inner : Int <- x + y in
                let outer : Int <- inner * 2 in
                    (new IO).out_string("Final result: ").out_int(outer);
        }
    };
};
\end{lstlisting}

\subsubsection{测试命令}
\begin{lstlisting}[style=bashstyle, caption={测试命令}]
$ ./mycoolc complex.cl
\end{lstlisting}

\subsubsection{AST输出对比}
我们的parser生成的AST结构与官方parser完全一致：

\textbf{我们的parser输出（test/myparser\_complex.output）：}
\begin{lstlisting}[style=bashstyle, caption={我们的parser输出}]
#11
_program
  #11
  _class
    Shape
    Object
    "complex.cl"
    (
    #12
    _attr
      x
      Int
      #12
      _int
        0
      : _no_type
    #13
    _attr
      y
      Int
      #13
      _int
        0
      : _no_type
    #14
    _attr
      name
      String
      #14
      _string
        "Generic Shape"
      : _no_type
    #17
    _method
      init
      #17
      _formal
        newX
        Int
      #17
      _formal
        newY
        Int
      #17
      _formal
        newName
        String
      SELF_TYPE
      #18
      _block
        #19
        _assign
          x
          #19
          _object
            newX
          : _no_type
        : _no_type
        #20
        _assign
          y
          #20
          _object
            newY
          : _no_type
        : _no_type
        #21
        _assign
          name
          #21
          _object
            newName
          : _no_type
        : _no_type
        #22
        _object
          self
        : _no_type
      : _no_type
    #27
    _method
      get_type_name
      String
      #28
      _object
        name
      : _no_type
    #32
    _method
      print_info
      #32
      _formal
        io
        IO
      IO
      #33
      _block
        #34
        _dispatch
          #34
          _dispatch
            #34
            _dispatch
              #34
              _object
                io
              : _no_type
              out_string
              (
              #34
              _string
                "Shape<"
              : _no_type
              )
            : _no_type
            out_string
            (
            #34
            _object
              name
            : _no_type
            )
          : _no_type
          out_string
          (
          #34
          _string
            ">"
          : _no_type
          )
        : _no_type
      : _no_type
    )
  #41
  _class
    Circle
    Shape
    "complex.cl"
    (
    #42
    _attr
      radius
      Int
      #0
      _no_expr
      : _no_type
\end{lstlisting}

\textbf{官方parser输出（test/official\_complex.output）：}
\begin{lstlisting}[style=bashstyle, caption={官方parser输出}]
#11
_program
  #11
  _class
    Shape
    Object
    "complex.cl"
    (
    #12
    _attr
      x
      Int
      #12
      _int
        0
      : _no_type
    #13
    _attr
      y
      Int
      #13
      _int
        0
      : _no_type
    #14
    _attr
      name
      String
      #14
      _string
        "Generic Shape"
      : _no_type
    #17
    _method
      init
      #17
      _formal
        newX
        Int
      #17
      _formal
        newY
        Int
      #17
      _formal
        newName
        String
      SELF_TYPE
      #18
      _block
        #19
        _assign
          x
          #19
          _object
            newX
          : _no_type
        : _no_type
        #20
        _assign
          y
          #20
          _object
            newY
          : _no_type
        : _no_type
        #21
        _assign
          name
          #21
          _object
            newName
          : _no_type
        : _no_type
        #22
        _object
          self
        : _no_type
      : _no_type
    #27
    _method
      get_type_name
      String
      #28
      _object
        name
      : _no_type
    #32
    _method
      print_info
      #32
      _formal
        io
        IO
      IO
      #33
      _block
        #34
        _dispatch
          #34
          _dispatch
            #34
            _dispatch
              #34
              _object
                io
              : _no_type
              out_string
              (
              #34
              _string
                "Shape<"
              : _no_type
              )
            : _no_type
            out_string
            (
            #34
            _object
              name
            : _no_type
            )
          : _no_type
          out_string
          (
          #34
          _string
            ">"
          : _no_type
          )
        : _no_type
      : _no_type
    )
  #41
  _class
    Circle
    Shape
    "complex.cl"
    (
    #42
    _attr
      radius
      Int
      #0
      _no_expr
      : _no_type
\end{lstlisting}

\subsection{自定义测试用例}
\subsubsection{main.cl 测试}
\textbf{测试目标：}验证语法分析器能够处理复杂的数据结构操作和多种数据类型。

\begin{lstlisting}[language=cool, caption={main.cl 测试用例}]
class Main inherits IO {
    main() : Object {
        let list : List <- (new List).list_init("MyList"),
            stack : Stack <- (new Stack).stack_init("MyStack"),
            queue : Queue <- (new Queue).queue_init("MyQueue"),
            bst : BST <- (new BST).bst_init("MyBST"),
            hash : HashTable <- (new HashTable).ht_init("MyHash", 10) in
        {
            -- 测试List
            list.insert(5);
            list.insert(10);
            list.insert(15);
            (new Mylib).println("List content:");
            list.print();
            
            -- 测试Stack
            stack.push(20);
            stack.push(25);
            stack.push(30);
            (new Mylib).println("Stack pop:");
            (new Mylib).item2a(stack.pop());
            
            -- 测试Queue
            queue.enqueue(40);
            queue.enqueue(45);
            queue.enqueue(50);
            (new Mylib).println("Queue dequeue:");
            (new Mylib).item2a(queue.dequeue());
            
            -- 测试BST
            bst.insert(100);
            bst.insert(50);
            bst.insert(150);
            (new Mylib).println("BST in-order:");
            bst.printInOrder();
            
            -- 测试HashTable
            hash.put(1, "One");
            hash.put(2, "Two");
            hash.put(3, "Three");
            (new Mylib).println("HashTable content:");
            hash.print();
        }
    };
};
\end{lstlisting}

\subsubsection{list.cl 测试}
\textbf{测试目标：}验证语法分析器能够处理链表数据结构的复杂操作和递归定义。

\begin{lstlisting}[language=cool, caption={list.cl 测试用例 - Node类}]
class Node inherits Object {
    val: Object;
    prev: Node;
    next: Node;
    
    node_init(v: Object): Node {
        {
            val <- v;
            prev <- self;
            next <- self;
            self;
        }
    };
    
    val(): Object { val };
    prev(): Node { prev };
    next(): Node { next };
    
    linkBehind(n: Node): Node {
        {
            n.setPrev(self);
            n.setNext(next);
            next.setPrev(n);
            next <- n;
            self;
        }
    };
    
    delete(): Node {
        {
            prev.setNext(next);
            next.setPrev(prev);
            self;
        }
    };
    
    print(): Object {
        {
            (new IO).out_string((new Mylib).item2a(val));
            if not (next = self) then
                {
                    (new IO).out_string(" <-> ");
                    next.print();
                }
            else
                (new IO).out_string("\n")
            fi;
        }
    };
};
\end{lstlisting}

\begin{lstlisting}[language=cool, caption={list.cl 测试用例 - List类}]
class List inherits Node {
    list_init(nam: String): List {
        {
            node_init(nam);
            self;
        }
    };
    
    insertIdx(item: Object, idx: Int): Bool {
        if idx = 0 then
            insertIdxN(item, idx)
        else if idx < 0 then
            false
        else if idx > length() then
            false
        else
            insertIdxN(item, idx)
        fi fi fi
    };
    
    insertIdxN(item: Object, idx: Int): Bool {
        if idx = 0 then
            {
                linkBehind((new Node).node_init(item));
                true;
            }
        else if idx < 0 then
            false
        else if idx > length() then
            false
        else
            {
                let cur: Node <- next in
                    (let i: Int <- 0 in
                        while i < idx loop
                            {
                                cur <- cur.next();
                                i <- i + 1;
                            }
                        pool
                    );
                cur.linkBehind((new Node).node_init(item));
                true;
            }
        fi fi fi
    };
    
    deleteIdx(idx: Int): Bool {
        if idx < 0 then
            false
        else if idx >= length() then
            false
        else
            {
                let cur: Node <- next in
                    (let i: Int <- 0 in
                        while i < idx loop
                            {
                                cur <- cur.next();
                                i <- i + 1;
                            }
                        pool
                    );
                cur.delete();
                true;
            }
        fi
    };
    
    insert(item: Object): Bool {
        insertIdx(item, length())
    };
    
    delete(item: Object): Bool {
        let cur: Node <- next,
            found: Bool <- false,
            i: Int <- 0 in
        {
            while (new Op).and(not found, i < length()) loop
                if (new Mylib).item2a(cur.val()) = (new Mylib).item2a(item) then
                    found <- true
                else
                    {
                        cur <- cur.next();
                        i <- i + 1;
                    }
                fi
            pool;
            
            if found then
                cur.delete()
            else
                false
            fi;
        }
    };
    
    search(item: Object): Bool {
        let cur: Node <- next,
            found: Bool <- false,
            i: Int <- 0 in
        {
            while (new Op).and(not found, i < length()) loop
                if (new Mylib).item2a(cur.val()) = (new Mylib).item2a(item) then
                    found <- true
                else
                    {
                        cur <- cur.next();
                        i <- i + 1;
                    }
                fi
            pool;
            found;
        }
    };
    
    isEmpty(): Bool { length() = 0 };
    
    length(): Int {
        let cur: Node <- self,
            count: Int <- 0 in
        {
            while not (cur = next) loop
                {
                    cur <- cur.next();
                    count <- count + 1;
                }
            pool;
            count;
        }
    };
    
    valx(idx: Int): Object {
        if idx < 0 then
            (new Throw).error("Index out of bounds")
        else if idx >= length() then
            (new Throw).error("Index out of bounds")
        else
            {
                let cur: Node <- next in
                    (let i: Int <- 0 in
                        while i < idx loop
                            {
                                cur <- cur.next();
                                i <- i + 1;
                            }
                        pool
                    );
                cur.val();
            }
        fi fi
    };
    
    nodex(idx: Int): Node {
        if idx < 0 then
            (new Throw).error("Index out of bounds")
        else if idx >= length() then
            (new Throw).error("Index out of bounds")
        else
            {
                let cur: Node <- next in
                    (let i: Int <- 0 in
                        while i < idx loop
                            {
                                cur <- cur.next();
                                i <- i + 1;
                            }
                        pool
                    );
                cur;
            }
        fi fi
    };
    
    print(): Object {
        if isEmpty() then
            (new IO).out_string("Empty List\n")
        else
            next.print()
        fi
    };
};
\end{lstlisting}

\subsubsection{base.cl 测试}
\textbf{测试目标：}验证语法分析器能够处理基础工具类和辅助函数。

\begin{lstlisting}[language=cool, caption={base.cl 测试用例 - Throw类}]
class Throw inherits IO {
  error(str: String): Object {
    {
      out_string("\n==== error info: ").out_string(str).out_string(" ====\n");
      abort();
    }
  };
  warning(str: String): Object {
    out_string("\n==== warning info: ").out_string(str).out_string(" ====\n")
  };
};
\end{lstlisting}

\begin{lstlisting}[language=cool, caption={base.cl 测试用例 - Op类}]
class Op inherits Object {
    -- 逻辑与运算：当两个参数都为true时返回true，否则返回false
  and(a: Bool, b: Bool): Bool {
    if a then b else false fi
  };
  
  -- 逻辑或运算：当两个参数中有一个为true时返回true，否则返回false
  or(a: Bool, b: Bool): Bool {
    if a then true else b fi
  };
  
  -- 逻辑异或运算：当两个参数不同时返回true，相同时返回false
  xor(a: Bool, b: Bool): Bool {
    if a then
        if b then false else true fi
    else
        if b then true else false fi
    fi
  };
  
  mod(a: Int, d: Int): Int {
    if d <= 0 then {
      (new Throw).error("Division by zero or minus in Op.mod");
      0;
    } else {
      (let quotient: Int <- a / d in {
        if and(a < 0, not (a - quotient * d) = 0) then {
            quotient <- quotient - 1;
        } else 0 fi;
        a - quotient * d;
      });
    }fi
  };
};
\end{lstlisting}

\begin{lstlisting}[language=cool, caption={base.cl 测试用例 - Mylib类}]
class Mylib inherits IO {
  i2b(int: Int): Bool {
    if not int = 0 then true else false fi
  };
  
  b2a(bool: Bool): String {
    if bool then "true" else "false" fi
  };
  
  item2a(it: Object): String {
    if isvoid it then {(new Throw).error("item2a received void."); "";} else
    case it of 
      s: String => s;
      i: Int => (new A2I).i2a(i);
      b: Bool => b2a(b);
      o: Object => "other type";
    esac
    fi
  };
  
  item2i(it: Object): Int {
    if isvoid it then {(new Throw).error("item2i received void."); 0;} else
    case it of 
      i: Int => i;
    esac
    fi
  };
  
  item2s(it: Object): String {
    if isvoid it then {(new Throw).error("item2s received void."); "";} else
    case it of 
      s: String => s;
    esac
    fi
  };
  
  item2b(it: Object): Bool {
    if isvoid it then {(new Throw).error("item2b received void."); false;} else
    case it of 
      b: Bool => b;
    esac
    fi
  };
  
  printspc(str: String): Mylib {
    out_string(str).out_string("  ")
  };
  
  printtab(str: String): Mylib {
    out_string(str).out_string("\t")
  };
  
  println(str: String): Mylib {
    out_string(str).out_string("\n")
  };
  
  debug(str: String, expr: Object): IO {
    out_string(str).out_string("=> ").out_string(item2a(expr)).out_string("\n")
  };
};
\end{lstlisting}

\begin{lstlisting}[language=cool, caption={base.cl 测试用例 - A2I类}]
class A2I {
  c2i(char : String) : Int {
    if char = "0" then 0 else
    if char = "1" then 1 else
    if char = "2" then 2 else
    if char = "3" then 3 else
    if char = "4" then 4 else
    if char = "5" then 5 else
    if char = "6" then 6 else
    if char = "7" then 7 else
    if char = "8" then 8 else
    if char = "9" then 9 else
    { abort(); 0; }
    fi fi fi fi fi fi fi fi fi fi
  };
  
  i2c(i : Int) : String {
    if i = 0 then "0" else
    if i = 1 then "1" else
    if i = 2 then "2" else
    if i = 3 then "3" else
    if i = 4 then "4" else
    if i = 5 then "5" else
    if i = 6 then "6" else
    if i = 7 then "7" else
    if i = 8 then "8" else
    if i = 9 then "9" else
    { abort(); ""; }
    fi fi fi fi fi fi fi fi fi fi
  };
  
  a2i(s : String) : Int {
    if s.length() = 0 then 0 else
    if s.substr(0,1) = "-" then ~a2i_aux(s.substr(1,s.length()-1)) else
    if s.substr(0,1) = "+" then a2i_aux(s.substr(1,s.length()-1)) else
      a2i_aux(s)
    fi fi fi
  };
  
  a2i_aux(s : String) : Int {
    (let int : Int <- 0 in
      {
        (let j : Int <- s.length() in
          (let i : Int <- 0 in
            while i < j loop
              {
                int <- int * 10 + c2i(s.substr(i,1));
                i <- i + 1;
              }
            pool
          )
        );
        int;
      }
    )
  };
  
  i2a(i : Int) : String {
    if i = 0 then "0" else
    if 0 < i then i2a_aux(i) else
      "-".concat(i2a_aux(i * ~1))
    fi fi
  };
  
  i2a_aux(i : Int) : String {
    if i = 0 then "" else
      (let next : Int <- i / 10 in
        i2a_aux(next).concat(i2c(i - next * 10))
      )
    fi
  };
};
\end{lstlisting}

\subsubsection{data-structures.cl 测试}
\textbf{测试目标：}验证语法分析器能够处理复杂数据结构类，包括栈、队列、二叉搜索树和哈希表。

\begin{lstlisting}[language=cool, caption={data-structures.cl 测试用例 - Stack类}]
class Stack inherits List {
    stack_init(nam: String): Stack {
        {
            list_init(nam);
            self;
        }
    };
    
    push(item: Object): Bool {
        insertIdx(item, 0)
    };
    
    pop(): Object {
        {
            if isEmpty() then {
                (new Throw).warning("Stack is empty, pop failed.");
            } else {
                let topVal: Object <- nodex(0).val() in {
                    deleteIdx(0);
                    topVal;
                };
            }fi;
        }
    };
    
    peek(): Object {
        if isEmpty() then {
            (new Throw).warning("Stack is empty, peek failed.");
        } else {
            nodex(0).val();
        }fi
    };
};
\end{lstlisting}

\begin{lstlisting}[language=cool, caption={data-structures.cl 测试用例 - Queue类}]
class Queue inherits List {
    queue_init(nam: String): Queue {
        {
            list_init(nam);
            self;
        }
    };
    
    enqueue(item: Object): Bool {
        insertIdx(item, length())
    };
    
    dequeue(): Object {
        if isEmpty() then {
            (new Throw).warning("Queue is empty, dequeue failed.");
        } else {
            let frontVal: Object <- nodex(0).val() in {
                deleteIdx(0);
                frontVal;
            };
        }fi
    };
    
    front(): Object {
        if isEmpty() then {
            (new Throw).warning("Queue is empty, front failed.");
        } else {
            nodex(0).val();
        }fi
    };
};
\end{lstlisting}

\begin{lstlisting}[language=cool, caption={data-structures.cl 测试用例 - BSTNode类}]
class BSTNode inherits Node {
    left: BSTNode;
    right: BSTNode;
    
    bstnode_init(v: Int): BSTNode {
        {
            node_init(v);
            self;
        }
    };
    
    left(): BSTNode { left };
    right(): BSTNode { right };
    
    setLeft(n: BSTNode): BSTNode { left <- n };
    setRight(n: BSTNode): BSTNode { right <- n };
    
    value(): Int {
        case val of
        i: Int => i;
        esac
    };
};
\end{lstlisting}

\begin{lstlisting}[language=cool, caption={data-structures.cl 测试用例 - BST类}]
class BST inherits Object {
    root: BSTNode;
    name: String;
    size: Int <- 0;
    
    bst_init(nam: String): BST {
        {
            name <- nam;
            self;
        }
    };
    
    insert(value: Int): Bool {
        let newNode: BSTNode <- (new BSTNode).bstnode_init(value) in {
            if isvoid root then {
                root <- newNode;
                size <- size + 1;
                true;
            } else {
                insertHelper(root, newNode);
                size <- size + 1;
                true;
            }fi;
        }
    };
    
    insertHelper(current: BSTNode, newNode: BSTNode): Object {
        let curVal: Int <- (new Mylib).item2i(current.val()),
            newVal: Int <- (new Mylib).item2i(newNode.val()) in {
            if newVal < curVal then
                if isvoid current.left() then
                    current.setLeft(newNode)
                else
                    insertHelper(current.left(), newNode)
                fi
            else
                if isvoid current.right() then
                    current.setRight(newNode)
                else
                    insertHelper(current.right(), newNode)
                fi
            fi;
        }
    };
    
    search(value: Int): Bool {
        if isvoid root then
            false
        else
            searchHelper(root, value)
        fi
    };
    
    searchHelper(current: BSTNode, value: Int): Bool {
        if isvoid current then
            false
        else
            let curVal: Int <- case current.val() of i: Int => i; esac in {
                if value = curVal then
                    true
                else if value < curVal then
                    searchHelper(current.left(), value)
                else
                    searchHelper(current.right(), value)
                fi fi;
            }
        fi
    };
    
    delete(value: Int): Bool {
        let result: Bool <- false in {
            if isvoid root then
                false
            else {
                root <- deleteHelper(root, value, result);
                if result then size <- size - 1 else 0 fi;
                result;
            }
            fi;
        }
    };
    
    deleteHelper(current: BSTNode, value: Int, result: Bool): BSTNode {
        if isvoid current then
            current
        else
            let curVal: Int <- (new Mylib).item2i(current.val()) in {
                if value < curVal then
                    current.setLeft(deleteHelper(current.left(), value, result))
                else if not value <= curVal then
                    current.setRight(deleteHelper(current.right(), value, result))
                else {
                    result <- true;
                    if (new Op).and(isvoid current.left(), isvoid current.right()) then
                        case (new BSTNode).node_init(new Object) of bn: BSTNode => bn; esac
                    else if isvoid current.right() then
                        current.left()
                    else if isvoid current.left() then
                        current.right()
                    else {
                        let successorVal: Int <- findMinVal(current.right()) in {
                            current.assign(successorVal);
                            current.setRight(deleteMin(current.right()));
                            current;
                        };
                    }fi fi fi;
                }fi fi;
            }
        fi
    };
    
    findMinVal(node: BSTNode): Int {
        if isvoid node.left() then
            case node.val() of i: Int => i; esac
        else
            findMinVal(node.left())
        fi
    };
    
    deleteMin(node: BSTNode): BSTNode {
        if isvoid node.left() then
            node.right()
        else {
            node.setLeft(deleteMin(node.left()));
            node;
        }
        fi
    };
    
    printInOrder(): Object {
        {
            (new IO).out_string(name).out_string(" => ");
            if isvoid root then
                (new IO).out_string("Empty BST\n")
            else {
                inOrder(root);
                (new IO).out_string("\n");
            }
            fi;
        }
    };
    
    inOrder(node: BSTNode): Object {
        if not isvoid node then {
            inOrder(node.left());
            (new IO).out_string((new A2I).i2a(case node.val() of i: Int => i; esac)).out_string(" ");
            inOrder(node.right());
        } else 0 fi
    };
    
    size(): Int { size };
    isEmpty(): Bool { size = 0 };
};
\end{lstlisting}

\begin{lstlisting}[language=cool, caption={data-structures.cl 测试用例 - Entry类}]
class Entry inherits Object {
    key: Int;
    value: String;
    
    init(k: Int, v: String): Entry {
        {
            key <- k;
            value <- v;
            self;
        }
    };
    
    getKey(): Int { key };
    getValue(): String { value };
    setValue(v: String): String {
        let old: String <- value in {
            value <- v;
            old;
        }
    };
    
    equalsKey(k: Int): Bool { key = k };
    
    print(): Object {
        (new IO).out_string("(").out_string((new A2I).i2a(key)).out_string(", \"").out_string(value).out_string("\")")
    };
};
\end{lstlisting}

\begin{lstlisting}[language=cool, caption={data-structures.cl 测试用例 - HashTable类}]
class HashTable inherits Object {
    buckets: List;
    capacity: Int;
    size: Int <- 0;
    name: String;
    
    ht_init(nam: String, cap: Int): HashTable {
        {
            name <- nam;
            capacity <- cap;
            buckets <- (new List).list_init("HashTable Buckets");
            
            (let i: Int <- 0 in {
                while i < capacity loop {
                    buckets.insertIdxN(
                        (new Node).node_init(
                            (new List).list_init("Bucket ".concat((new A2I).i2a(i)))
                        ), 
                        i
                    );
                    i <- i + 1;
                }pool;
            });
            self;
        }
    };
    
    hashFunc(key: Int): Int {
        (new Op).mod(key, capacity)
    };
    
    getBucket(index: Int): List {
        let node: Node <- case buckets.nodex(index) of n: Node => n; esac in
            case node.val() of
                b: List => b;
            esac
    };
    
    put(key: Int, value: String): String {
        let index: Int <- hashFunc(key),
            bucket: List <- getBucket(index),
            i: Int <- 0,
            found: Bool <- false,
            oldValue: String <- "" in
        {
            while (new Op).and(i < bucket.length(), not found) loop
                let entryNode: Node <- case bucket.nodex(i) of n: Node => n; esac,
                    entry: Entry <- case entryNode.val() of e: Entry => e; esac in
                {
                    if entry.equalsKey(key) then
                        {
                            oldValue <- entry.setValue(value);
                            found <- true;
                        }
                    else
                        i <- i + 1
                    fi;
                }
            pool;
            
            if not found then
                {
                    bucket.insert(new Entry.init(key, value));
                    size <- size + 1;
                    oldValue <- "";
                }
            else
                oldValue
            fi;
        }
    };
    
    get(key: Int): String {
        let index: Int <- hashFunc(key),
            bucket: List <- getBucket(index),
            i: Int <- 0,
            result: String <- "=== not exist ===" in
        {
            while (new Op).and(i < bucket.length(), result = "=== not exist ===") loop
                let entryNode: Node <- case bucket.nodex(i) of n: Node => n; esac,
                    entry: Entry <- case entryNode.val() of e: Entry => e; esac in
                {
                    if entry.equalsKey(key) then
                        result <- entry.getValue()
                    else
                        i <- i + 1
                    fi;
                }
            pool;
            result;
        }
    };
    
    remove(key: Int): String {
        let index: Int <- hashFunc(key),
            bucket: List <- getBucket(index),
            i: Int <- 0,
            removedValue: String <- "" in
        {
            while (new Op).and(i < bucket.length(), removedValue = "") loop
                let entryNode: Node <- case bucket.nodex(i) of n: Node => n; esac,
                    entry: Entry <- case entryNode.val() of e: Entry => e; esac in
                {
                    if entry.equalsKey(key) then
                        {
                            removedValue <- entry.getValue();
                            bucket.deleteIdx(i);
                            size <- size - 1;
                        }
                    else
                        i <- i + 1
                    fi;
                }
            pool;
            removedValue;
        }
    };

    printBucket(bucket: List): Object {
        let i: Int <- 0 in {
            (new IO).out_string("[");
            while i < bucket.length() loop
                {
                    let entryNode: Node <- case bucket.nodex(i) of n: Node => n; esac,
                        entry: Entry <- case entryNode.val() of e: Entry => e; esac in
                    {
                        entry.print();
                    };
                    
                    if i < bucket.length()-1 then
                        (new IO).out_string(", ")
                    else
                        0
                    fi;
                    
                    i <- i + 1;
                }
            pool;
            (new IO).out_string("]");
        }
    };
    
    print(): Object {
        {
            (new IO).out_string(name).out_string(" (capacity: ").out_string((new A2I).i2a(capacity)).out_string(", size: ").out_string((new A2I).i2a(size)).out_string(")\n");
            let i: Int <- 0 in {
                while i < capacity loop {
                    let bucket: List <- getBucket(i) in {
                        (new IO).out_string("Bucket ".concat((new A2I).i2a(i))).out_string(" [").out_string((new A2I).i2a(bucket.length())).out_string(" entries]: ");
                        printBucket(bucket);
                        (new IO).out_string("\n");
                    };
                    i <- i + 1;
                }pool;
            };
        }
    };
    
    getSize(): Int { size };
    getCapacity(): Int { capacity };
    isEmpty(): Bool { size = 0 };
};
\end{lstlisting}

\texttt{以上main.cl、base.cl、list.cl、data-structures.cl的组合测试已成功通过，不再展示。}

\subsection{测试结果汇总}

本项目的测试分为两部分：语法分析器测试（myparser）和完整编译器测试（mycoolc）。测试方法使用自定义的测试脚本test\_parser.sh和test\_coolc.sh，将我们的实现与官方工具进行对比。

\subsubsection{语法分析器测试结果}
语法分析器测试验证了我们实现的Bison语法规则能够正确解析COOL语言程序并生成与官方parser完全一致的AST结构。

\begin{table}[htbp]
\centering
\footnotesize % 使用更小的字体
\renewcommand{\tabularxcolumn}[1]{m{#1}} % 使内容垂直居中
\begin{tabularx}{\columnwidth}{@{}lccX@{}}
\toprule
\textbf{测试文件} & \textbf{行数} & \textbf{测试项} & \textbf{说明} \\
\midrule
good.cl & 8 & 基本语法解析 & AST结构与官方完全一致 \\
bad.cl & 29 & 错误检测 & 正确检测语法错误并生成错误AST \\
stack.cl & 185 & 栈数据结构 & 栈操作正确解析 \\
complex.cl & 152 & 复杂表达式 & 嵌套结构正确处理 \\
data-structures.cl & 590 & 复杂数据结构 & BST、哈希表等正确解析 \\
\midrule
\multicolumn{3}{@{}l}{\textbf{总计}} & \textbf{所有测试文件AST结构与官方完全一致} \\
\bottomrule
\end{tabularx}
\end{table}

\textbf{测试方法}：使用test\_parser.sh脚本对比myparser和官方parser的输出。测试结果表明，所有测试文件的AST结构、节点类型、行号等信息与官方parser完全一致，diff命令没有任何输出，表明我们的语法分析器达到了100\%的准确度。

\subsubsection{完整编译器测试结果}
完整编译器测试验证了我们的语法分析器与词法分析器、语义分析器的集成能够正确处理COOL语言程序。

\begin{table}[htbp]
\centering
\footnotesize % 使用更小的字体
\renewcommand{\tabularxcolumn}[1]{m{#1}} % 使内容垂直居中
\begin{tabularx}{\columnwidth}{@{}lccX@{}}
\toprule
\textbf{测试文件} & \textbf{行数} & \textbf{测试项} & \textbf{说明} \\
\midrule
good.cl & 8 & 基本语法解析 & 输出与官方完全一致 \\
bad.cl & 29 & 错误检测 & 正确检测语法错误 \\
base.cl & 421 & 基础工具类 & 辅助函数正确解析 \\
list.cl & 234 & 链表操作 & 链表递归定义正确 \\
stack.cl & 185 & 栈数据结构 & 栈操作正确实现 \\
complex.cl & 152 & 复杂表达式 & 嵌套结构正确处理 \\
main.cl & 134 & 数据结构集合 & 多种数据结构正确解析 \\
data-structures.cl & 590 & 复杂数据结构 & BST、哈希表等正确解析 \\
\midrule
\multicolumn{3}{@{}l}{\textbf{总计}} & \textbf{所有测试文件输出与官方完全一致} \\
\bottomrule
\end{tabularx}
\end{table}

\textbf{测试方法}：使用test\_coolc.sh脚本对比mycoolc和官方coolc的输出。测试结果表明，所有测试文件的输出与官方coolc完全一致，包括错误信息和语义检查结果。

\subsubsection{多文件组合测试}
特别测试了main.cl、base.cl、list.cl和data-structures.cl四个文件的组合编译，验证了语法分析器在处理多文件项目时的正确性。测试结果表明，我们的实现能够正确处理多文件之间的依赖关系和类继承关系。

\subsubsection{测试结论}
通过全面的测试验证，我们的语法分析器实现了以下目标：
\begin{itemize}
\item 正确解析COOL语言的所有语法结构
\item 生成与官方parser完全一致的AST结构
\item 正确处理语法错误并提供有意义的错误信息
\item 与词法分析器和语义分析器无缝集成
\item 支持多文件项目的编译
\end{itemize}

\section{遇到的问题与解决方案}
在实现COOL语言语法分析器的过程中，我们遇到了以下几个主要问题：

\subsection{移进-归约冲突问题}
在处理COOL语言的if-then-else结构时，遇到了典型的"悬空else"问题，导致移进-归约冲突。

\textbf{解决方案}：通过在Bison中声明\%nonassoc ELSE和\%nonassoc IF，并使用优先级和结合性规则解决冲突。具体来说，声明ELSE的优先级高于IF，使得else关键字优先与最近的if匹配。

\subsection{运算符优先级和结合性问题}
COOL语言支持多种运算符，包括算术运算符、比较运算符和逻辑运算符，需要正确处理它们的优先级和结合性。

\textbf{解决方案}：在Bison中使用\%left、\%right和\%nonassoc声明运算符的优先级和结合性。例如，声明\%left '+' '-'、\%left '*' '/'、\%nonassoc '<' '<=' '='等，确保表达式按照预期规则解析。

\subsection{Let表达式实现问题}
Let表达式支持多个变量绑定，如何设计文法规则以支持这种结构是一个挑战。

\textbf{解决方案}：引入let\_chain非终结符来处理多个绑定的let表达式。通过递归定义let\_chain，支持任意数量的变量绑定，并正确处理初始化表达式和in子句。

\subsection{错误恢复机制实现}
当遇到语法错误时，如何使解析器能够继续解析并报告更多错误，而不是立即终止。

\textbf{解决方案}：使用Bison的错误恢复机制，在语法规则中插入error标记，并配合yyerrok和yyclearin函数。例如，在类定义、方法定义和表达式等关键位置添加错误恢复规则，使解析器能够跳过错误部分继续解析。

\subsection{行号设置问题}
在语法分析过程中，需要正确记录每个语法元素的行号，以便在错误报告中提供准确的位置信息。

\textbf{解决方案}：在Bison语法规则中使用\@N符号（N为规则右侧的符号位置）来获取符号的行号信息，并在创建抽象语法树节点时传递这些行号信息。例如，在表达式规则中使用\@1和\@3获取操作符和操作数的行号。

\subsection{列表构建问题}
在处理列表表达式时，如何正确构建列表结构是一个挑战，特别是处理空列表和单元素列表的情况。

\textbf{解决方案}：设计专门的语法规则处理列表构建，使用递归或迭代方式处理列表元素。对于空列表和单元素列表，使用不同的语法规则分支，确保所有情况都能正确处理。

\section{cool.y 实现细节}
\subsection{Token声明}
\begin{lstlisting}[language=bison]
%token CLASS 258 ELSE 259 FI 260 IF 261 IN 262
%token INHERITS 263 LET 264 LOOP 265 POOL 266 THEN 267 WHILE 268
%token CASE 269 ESAC 270 OF 271 DARROW 272 NEW 273 ISVOID 274
%token <symbol>  STR_CONST 275 INT_CONST 276
%token <boolean> BOOL_CONST 277
%token <symbol> TYPEID 278 OBJECTID 279
%token ASSIGN 280 NOT 281 LE 282 ERROR 283
%token '(' ')' ':' ';' ',' '@' '.' '{' '}' '+' '-' '*' '/' '<' '~'
\end{lstlisting}

\subsection{优先级和结合性声明}
\begin{lstlisting}[language=bison]
%nonassoc IN  /* 最低优先级 */
%right ASSIGN  /* 赋值右结合 */
%right NOT  /* NOT右结合 */
%nonassoc LE '<' '='  /* 比较运算符无结合 */
%left '+' '-'  /* 加减左结合 */
%left '*' '/'  /* 乘除左结合，优先级高于加减 */
%left ISVOID  /* ISVOID左结合 */
%left '~'  /* 取反左结合 */
%left '@'  /* 静态分发左结合 */
%left '.'  /* 方法调用左结合，最高优先级 */
\end{lstlisting}

\subsection{关键语法规则实现}
\subsubsection{程序入口}
\begin{lstlisting}[language=bison]
program : class_list 
    { 
        @$ = @1; 
        ast_root = program($1); 
    }
    ;
\end{lstlisting}

\subsubsection{类定义}
\begin{lstlisting}[language=bison]
class_list : class /* single class */
    { 
        $ = single_Classes($1); 
    }
    | class_list class /* multiple classes */
    { 
        $ = append_Classes($1, single_Classes($2)); 
    }
    ;

class : CLASS TYPEID '{' feature_list '}' ';'
    { 
        @$ = @1; 
        $ = class_($2, idtable.add_string("Object"), $4, 
                   stringtable.add_string(curr_filename)); 
    }
    | CLASS TYPEID INHERITS TYPEID '{' feature_list '}' ';'
    { 
        @$ = @1; 
        $ = class_($2, $4, $6, stringtable.add_string(curr_filename)); 
    }
    ;
\end{lstlisting}

\subsubsection{Let表达式实现}
\begin{lstlisting}[language=bison]
let_chain : OBJECTID ':' TYPEID IN expr
    { 
        @$ = @1; 
        $ = let($2, $3, no_expr, $5); 
    }
    | OBJECTID ':' TYPEID ASSIGN expr IN expr
    { 
        @$ = @1; 
        $ = let($2, $3, $5, $7); 
    }
    | OBJECTID ':' TYPEID ',' let_chain
    { 
        @$ = @1; 
        $ = let($2, $3, no_expr, $5); 
    }
    | OBJECTID ':' TYPEID ASSIGN expr ',' let_chain
    { 
        @$ = @1; 
        $ = let($2, $3, $5, $7); 
    }
    ;
\end{lstlisting}

\subsubsection{错误恢复}
\begin{lstlisting}[language=bison]
class : CLASS TYPEID '{' feature_list '}' ';'
    | error ';' /* 错误恢复：跳过到分号 */
    { 
        @$ = @1; 
        $ = class_(idtable.add_string("_Error"), 
                    idtable.add_string("Object"), 
                    nil_Features(), 
                    stringtable.add_string(curr_filename)); 
    }
    ;
\end{lstlisting}

\section{总结}
通过本次实验，我深入理解了语法分析的理论基础和Bison工具的工作原理。从上下文无关文法和LR分析的理论出发，理解了Bison如何将文法规则转换为LALR(1)分析表，如何进行移进-归约分析。在实践中，我成功实现了一个功能完整且健壮的COOL语言语法分析器，特别是掌握了优先级和结合性声明在解决移进-归约冲突时的应用，以及let表达式的实现方式。通过完整的测试，我验证了语法分析器能够正确解析COOL语言程序，并有效处理语法错误。这次实验让我对编译器前端有了全面而深刻的认识，为后续的语义分析和代码生成阶段奠定了坚实的基础。

\section{参考文献}
\begin{thebibliography}{9}
\bibitem{bison-manual}
Donnelly C., Stallman R.
\textit{Bison: The Yacc-compatible Parser Generator}.
Free Software Foundation, 2022.

\bibitem{dragon-book}
Aho A.V., Lam M.S., Sethi R., Ullman J.D.
\textit{Compilers: Principles, Techniques, and Tools} (2nd Edition).
Addison-Wesley, 2006.

\bibitem{cool-manual}
Alex Aiken.
\textit{The COOL Programming Language}.
Stanford University, 2023.

\bibitem{flex-manual}
Paxson V., Estes C.
\textit{Flex: The Fast Lexical Analyzer Generator}.
Free Software Foundation, 2022.

\bibitem{lr-parsing}
Grune D., Jacobs C.J.H.
\textit{Parsing Techniques: A Practical Guide} (2nd Edition).
Springer, 2008.
\end{thebibliography}

\appendix
\section{附录: cool.y 完整源码}
\label{sec:appendix_code}

\IfFileExists{cool.y}
  {\lstinputlisting[language=bison, basicstyle=\ttfamily\tiny]{cool.y}}
  {
\textbf{说明：}将完成的 \texttt{cool.y} 文件放在同一目录下，重新编译即可自动包含完整代码。
}

\end{document}
